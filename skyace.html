<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SKY ACE 1945 | ÁµïÂ∞çÈò≤Áï∂Ê©üÁâà</title>
    <style>
        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            background: #050505; overflow: hidden; 
            font-family: 'Courier New', monospace;
            touch-action: none; user-select: none; -webkit-user-select: none;
        }

        #game-stage {
            position: relative; width: 100%; height: 100%; max-width: 600px; margin: 0 auto;
            background: #002244; 
            overflow: hidden;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            cursor: none; 
        }

        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }

        /* ÊéÉÊèèÁ∑ö - Èôç‰ΩéÈÄèÊòéÂ∫¶Ê∏õÂ∞ëË¶ñË¶∫Áñ≤Âãû */
        #scanlines {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.03));
            background-size: 100% 4px, 6px 100%;
            pointer-events: none; z-index: 10;
        }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 20;
            padding: 20px; box-sizing: border-box;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        .hud-top { display: flex; justify-content: space-between; color: #fff; text-shadow: 2px 2px 0 #000; }
        .score-box { font-size: 20px; font-weight: bold; text-align: left; }
        .life-box { font-size: 20px; color: #ff3b30; text-align: right; }
        
        .weapon-status { font-size: 12px; color: #f1c40f; margin-top: 5px; font-weight: bold; }
        .sub-status { color: #3498db; }
        .diff-status { color: #e74c3c; margin-top: 2px; }

        #boss-hud {
            position: absolute; top: 70px; left: 50%; transform: translateX(-50%);
            width: 70%; display: none; flex-direction: column; align-items: center;
        }
        #boss-name { color: #ff3b30; font-weight: 900; font-size: 14px; margin-bottom: 3px; text-shadow: 2px 2px 0 #000; }
        #boss-hp-bar { width: 100%; height: 8px; background: #330000; border: 2px solid #fff; }
        #boss-hp-fill { width: 100%; height: 100%; background: #ff3b30; transition: width 0.1s; }

        #warning-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 0, 0, 0.3); opacity: 0; pointer-events: none; z-index: 15;
            display: flex; justify-content: center; align-items: center;
        }
        .warning-text { font-size: 50px; color: #fff; font-weight: 900; letter-spacing: 5px; transform: rotate(-10deg); text-shadow: 4px 4px 0 #ff0000; display: none; }
        .flash-anim { animation: flashScreen 0.5s infinite; }
        @keyframes flashScreen { 0%, 100% { opacity: 0; } 50% { opacity: 1; } }

        #flash-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #fff; opacity: 0; pointer-events: none; z-index: 15;
            transition: opacity 0.1s;
        }

        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #fff; text-align: center;
        }
        .title { font-size: 40px; color: #f1c40f; text-shadow: 4px 4px 0 #c0392b; margin-bottom: 20px; font-weight: 900; letter-spacing: 3px; }
        .blink { animation: blink 1s infinite; font-size: 14px; }
        @keyframes blink { 50% { opacity: 0; } }
        
        .btn {
            background: #c0392b; color: #fff; border: 2px solid #fff;
            padding: 12px 30px; font-size: 20px; font-weight: bold; cursor: pointer;
            margin-top: 20px; box-shadow: 0 4px 0 #7f261c; transition: transform 0.1s;
        }
        .btn:active { transform: translateY(4px); box-shadow: 0 0 0 #7f261c; }

        #game-over-ui { display: none; flex-direction: column; align-items: center; }

        .home-btn {
            position: fixed; top: 15px; left: 15px; z-index: 200; pointer-events: auto;
            text-decoration: none; font-size: 24px; width: 40px; height: 40px;
            background: rgba(0,0,0,0.5); border: 2px solid #fff; border-radius: 5px;
            display: flex; align-items: center; justify-content: center; color: #fff;
        }
    </style>
</head>
<body>

<a href="index.html" class="home-btn">üè†</a>

<div id="game-stage">
    <canvas id="gameCanvas"></canvas>
    <div id="scanlines"></div>
    <div id="flash-overlay"></div>
    <div id="warning-overlay"><div class="warning-text">WARNING!!</div></div>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="score-box">
                SCORE: <span id="score">0</span>
                <div class="weapon-status" id="weapon-display">MAIN: NORMAL</div>
                <div class="weapon-status sub-status" id="sub-weapon-display">SUB: NONE</div>
                <div class="weapon-status diff-status" id="diff-display">THREAT: 100%</div>
            </div>
            <div class="life-box" id="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
        </div>
        <div id="boss-hud">
            <div id="boss-name">‚ö† AERIAL FORTRESS TITAN ‚ö†</div>
            <div id="boss-hp-bar"><div id="boss-hp-fill"></div></div>
        </div>
    </div>

    <div id="start-screen">
        <div id="main-menu">
            <div class="title">SKY ACE<br>1945</div>
            <p class="blink">INSERT COIN TO START</p>
            <button class="btn" onclick="startGame()">MISSION START</button>
            <p style="margin-top: 20px; font-size: 12px; color: #aaa;">HOLD TO SHOOT ‚Ä¢ DODGE</p>
        </div>
        <div id="game-over-ui">
            <div class="title" style="color: #ff3b30;">DEFEATED</div>
            <div style="font-size: 20px; margin-bottom: 20px;">SCORE: <span id="final-score">0</span></div>
            <button class="btn" onclick="startGame()">RETRY</button>
        </div>
    </div>
</div>

<script>
    // --- 1. Ê†∏ÂøÉË®≠ÁΩÆËàáÈò≤ÂëÜ ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // UI ÂÖÉÁ¥†Âø´Âèñ
    const ui = {
        warningOverlay: document.getElementById('warning-overlay'),
        warningText: document.querySelector('.warning-text'),
        bossHud: document.getElementById('boss-hud'),
        bossHpFill: document.getElementById('boss-hp-fill'),
        flashOverlay: document.getElementById('flash-overlay'),
        score: document.getElementById('score'),
        lives: document.getElementById('lives'),
        weapon: document.getElementById('weapon-display'),
        subWeapon: document.getElementById('sub-weapon-display'),
        diff: document.getElementById('diff-display'),
        startScreen: document.getElementById('start-screen'),
        mainMenu: document.getElementById('main-menu'),
        gameOverUi: document.getElementById('game-over-ui'),
        finalScore: document.getElementById('final-score')
    };

    let GAME_WIDTH = 320, GAME_HEIGHT = 568;
    
    // ÈÅäÊà≤ËÆäÊï∏
    let gameState = 'MENU';
    let score = 0, lives = 3, frameCount = 0;
    let input = { x: 160, y: 400, active: false };
    
    // Èõ£Â∫¶Ëàá Boss
    let nextBossScore = 20000;
    const BOSS_INTERVAL = 80000;
    let bossLevel = 1;
    let bossActive = false;
    let difficultyMultiplier = 1.0;

    // Áâ©‰ª∂Ê±† (‰ΩøÁî®Èô£ÂàóÔºå‰ΩÜÂö¥Ê†ºÊéßÂà∂Èï∑Â∫¶)
    let player;
    let bullets = [];
    let enemies = [];
    let particles = [];
    let powerups = [];
    let clouds = [];
    let textPopups = [];
    let boss = null;

    // --- 2. ÂúñÂÉèÊï∏Êìö (Sprites) ---
    const SPRITES = {
        PLAYER: [[0,0,0,1,0,0,0],[0,0,1,1,1,0,0],[0,1,1,2,1,1,0],[1,1,1,2,1,1,1],[1,0,1,2,1,0,1],[0,0,1,2,1,0,0],[0,1,1,0,1,1,0]],
        ENEMY_SMALL: [[0,0,1,1,1,0,0],[0,1,1,1,1,1,0],[1,1,0,1,0,1,1],[0,0,0,1,0,0,0],[0,0,1,0,1,0,0]],
        ENEMY_SHOOTER: [[0,1,0,0,0,1,0],[1,1,1,1,1,1,1],[0,1,1,2,1,1,0],[0,0,1,2,1,0,0],[0,0,0,1,0,0,0]],
        BOSS: [
            [0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
            [0,0,0,0,1,1,2,2,2,2,2,2,2,2,1,1,0,0,0,0],
            [0,0,1,1,2,2,2,2,3,3,3,3,2,2,2,2,1,1,0,0],
            [0,1,2,2,2,3,3,3,3,4,4,3,3,3,3,2,2,2,1,0],
            [1,2,2,3,3,4,4,4,4,4,4,4,4,4,4,3,3,2,2,1],
            [1,2,2,3,3,4,4,4,4,4,4,4,4,4,4,3,3,2,2,1],
            [1,2,2,2,2,2,3,3,3,3,3,3,3,3,2,2,2,2,2,1],
            [0,1,2,1,2,1,2,1,2,2,2,2,1,2,1,2,1,2,1,0],
            [0,0,1,0,1,0,1,0,2,2,2,2,0,1,0,1,0,1,0,0],
            [0,0,0,0,0,0,0,0,1,2,2,1,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0]
        ],
        // Â≠êÂΩà
        BULLET_P: [[1,2],[1,2],[1,2]],
        BULLET_E: [[2,1,2],[1,1,1],[2,1,2]],
        BULLET_LASER: [[1],[2],[1],[2],[1]],
        BULLET_MISSILE: [[0,1,0],[1,2,1],[1,2,1],[1,2,1],[0,1,0]],
        // ÈÅìÂÖ∑
        ITEM_DOUBLE: [[1,1,1],[1,0,1],[1,1,1],[1,0,0],[1,0,0]],
        ITEM_MISSILE: [[1,0,1],[1,1,1],[1,0,1],[1,0,1],[1,0,1]],
        ITEM_LASER: [[1,0,0],[1,0,0],[1,0,0],[1,0,0],[1,1,1]],
        ITEM_BOMB: [[1,1,0],[1,0,1],[1,1,0],[1,0,1],[1,1,0]],
        ITEM_SHIELD: [[0,1,1],[1,0,0],[0,1,0],[0,0,1],[1,1,0]],
        ITEM_HEART: [[1,0,1],[1,0,1],[1,1,1],[1,0,1],[1,0,1]],
        ITEM_SPREAD: [[1,0,1],[1,0,1],[1,1,1],[1,1,1],[1,0,1]]
    };

    function resize() {
        const stage = document.getElementById('game-stage');
        GAME_WIDTH = stage.clientWidth;
        GAME_HEIGHT = stage.clientHeight;
        canvas.width = GAME_WIDTH;
        canvas.height = GAME_HEIGHT;
    }
    window.addEventListener('resize', resize);
    resize();

    // Áπ™ÂúñÂáΩÊï∏ÔºöÂä†ÂÖ•Èò≤ÂëÜÊ™¢Êü•
    function drawSprite(ctx, sprite, cx, cy, colors, scale = 1, rotation = 0) {
        if (!isFinite(cx) || !isFinite(cy)) return; 
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(rotation);
        const rows = sprite.length;
        const cols = sprite[0].length;
        const pixelSize = 3 * scale;
        const startX = - (cols * pixelSize) / 2;
        const startY = - (rows * pixelSize) / 2;

        for(let r=0; r<rows; r++) {
            for(let c=0; c<cols; c++) {
                const val = sprite[r][c];
                if (val > 0 && colors[val-1]) {
                    ctx.fillStyle = colors[val-1];
                    ctx.fillRect(startX + c*pixelSize, startY + r*pixelSize, pixelSize, pixelSize);
                }
            }
        }
        ctx.restore();
    }

    // ÊµÆÂãïÊñáÂ≠ó
    class FloatingText {
        constructor(x, y, text, color) {
            this.x = x; this.y = y; this.text = text; this.color = color;
            this.life = 60; this.vy = -1.5;
        }
        update() { this.y += this.vy; this.life--; }
        draw(ctx) {
            if(this.life <= 0) return;
            ctx.save();
            ctx.globalAlpha = Math.max(0, this.life / 60);
            ctx.fillStyle = this.color;
            ctx.font = "bold 16px Courier New";
            ctx.strokeStyle = "black";
            ctx.lineWidth = 3;
            ctx.textAlign = "center";
            ctx.strokeText(this.text, this.x, this.y);
            ctx.fillText(this.text, this.x, this.y);
            ctx.restore();
        }
    }

    // --- 3. Èü≥ÊïàÁ≥ªÁµ± (Èò≤Áï∂Ê©üÂÑ™ÂåñÁâà) ---
    let audioCtx;
    const soundCooldowns = {}; // Èü≥ÊïàÂÜ∑ÂçªË°®

    function initAudio() {
        if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if(audioCtx.state === 'suspended') audioCtx.resume();
    }

    function playSound(type) {
        if(!audioCtx) return;
        const now = audioCtx.currentTime;
        
        // ‚òÖ Âº∑Âà∂ÂÜ∑ÂçªÔºöÂêå‰∏ÄÈü≥ÊïàÂú® 80ms ÂÖßÂè™Êí≠‰∏ÄÊ¨°
        if (soundCooldowns[type] && now - soundCooldowns[type] < 0.08) return;
        soundCooldowns[type] = now;

        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        // Á∞°ÂåñÁöÑÈü≥ÊïàÁîüÊàê (Ê∏õÂ∞ëÈÅãÁÆó)
        if (type === 'SHOOT') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(800, now);
            osc.frequency.exponentialRampToValueAtTime(300, now + 0.1);
            gain.gain.setValueAtTime(0.05, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.1);
            osc.start(); osc.stop(now + 0.1);
        } else if (type === 'EXPLODE') {
            const bufferSize = audioCtx.sampleRate * 0.2; // 0.2ÁßíÁü≠Âô™Èü≥
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 800;
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.2);
            noise.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination);
            noise.start();
            return; // Âô™Èü≥‰∏çÈúÄË¶Åoscillator
        } else if (type === 'POWERUP') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(600, now);
            osc.frequency.linearRampToValueAtTime(1200, now + 0.2);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.2);
            osc.start(); osc.stop(now + 0.2);
        } else if (type === 'ALARM') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(600, now);
            osc.frequency.linearRampToValueAtTime(400, now + 0.5);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.5);
            osc.start(); osc.stop(now + 0.5);
        } else if (type === 'BOMB') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, now);
            osc.frequency.linearRampToValueAtTime(50, now + 0.8);
            gain.gain.setValueAtTime(0.5, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.8);
            osc.start(); osc.stop(now + 0.8);
        }

        if (osc) {
            osc.connect(gain);
            gain.connect(audioCtx.destination);
        }
    }

    // --- 4. ÈÅäÊà≤ÂØ¶È´î ---
    
    class Player {
        constructor() {
            this.x = GAME_WIDTH / 2; this.y = GAME_HEIGHT - 80;
            this.w = 20; this.h = 20;
            this.weapon = 'DEFAULT'; this.weaponLevel = 1; this.missileLevel = 0;
            this.shootTimer = 0; this.invincible = 0; this.shield = false;
        }
        update() {
            if (input.active) {
                const targetY = input.y - 40;
                this.x += (input.x - this.x) * 0.2;
                this.y += (targetY - this.y) * 0.2;
            }
            // ÈÇäÁïåÈôêÂà∂
            this.x = Math.max(20, Math.min(GAME_WIDTH - 20, this.x));
            this.y = Math.max(20, Math.min(GAME_HEIGHT - 20, this.y));

            let fireRate = 8;
            if (this.weapon === 'LASER') fireRate = 12;
            
            this.shootTimer++;
            if (this.shootTimer > fireRate) { this.shoot(); this.shootTimer = 0; }
            if (this.invincible > 0) this.invincible--;
        }
        shoot() {
            playSound('SHOOT');
            // ‰∏ªÊ≠¶Âô®
            if (this.weapon === 'DEFAULT') {
                bullets.push(new Bullet(this.x, this.y - 15, 0, -8, 'PLAYER', 'NORMAL'));
            } else if (this.weapon === 'DOUBLE') {
                if(this.weaponLevel >= 1) {
                    bullets.push(new Bullet(this.x - 8, this.y - 15, 0, -8, 'PLAYER', 'NORMAL'));
                    bullets.push(new Bullet(this.x + 8, this.y - 15, 0, -8, 'PLAYER', 'NORMAL'));
                }
                if(this.weaponLevel >= 2) {
                    bullets.push(new Bullet(this.x - 12, this.y - 10, -1, -8, 'PLAYER', 'NORMAL'));
                    bullets.push(new Bullet(this.x + 12, this.y - 10, 1, -8, 'PLAYER', 'NORMAL'));
                }
                if(this.weaponLevel >= 3) {
                    bullets.push(new Bullet(this.x - 16, this.y - 5, -2, -8, 'PLAYER', 'NORMAL'));
                    bullets.push(new Bullet(this.x + 16, this.y - 5, 2, -8, 'PLAYER', 'NORMAL'));
                }
            } else if (this.weapon === 'SPREAD') {
                bullets.push(new Bullet(this.x, this.y - 15, 0, -8, 'PLAYER', 'NORMAL'));
                bullets.push(new Bullet(this.x, this.y - 15, -2, -7, 'PLAYER', 'NORMAL'));
                bullets.push(new Bullet(this.x, this.y - 15, 2, -7, 'PLAYER', 'NORMAL'));
                if(this.weaponLevel >= 2) {
                    bullets.push(new Bullet(this.x, this.y - 15, -4, -6, 'PLAYER', 'NORMAL'));
                    bullets.push(new Bullet(this.x, this.y - 15, 4, -6, 'PLAYER', 'NORMAL'));
                }
                if(this.weaponLevel >= 3) {
                    bullets.push(new Bullet(this.x, this.y - 15, -6, -5, 'PLAYER', 'NORMAL'));
                    bullets.push(new Bullet(this.x, this.y - 15, 6, -5, 'PLAYER', 'NORMAL'));
                }
            } else if (this.weapon === 'LASER') {
                bullets.push(new Bullet(this.x, this.y - 20, 0, -15, 'PLAYER', 'LASER'));
                if(this.weaponLevel >= 2) {
                    bullets.push(new Bullet(this.x - 6, this.y - 20, 0, -15, 'PLAYER', 'LASER'));
                    bullets.push(new Bullet(this.x + 6, this.y - 20, 0, -15, 'PLAYER', 'LASER'));
                }
                if(this.weaponLevel >= 3) {
                    bullets.push(new Bullet(this.x - 12, this.y - 20, 0, -15, 'PLAYER', 'LASER'));
                    bullets.push(new Bullet(this.x + 12, this.y - 20, 0, -15, 'PLAYER', 'LASER'));
                }
            }

            // ÂâØÊ≠¶Âô® (Â∞éÂΩà) - Ê∏õÈ†ªÁôºÂ∞Ñ
            if (this.missileLevel > 0 && frameCount % 20 === 0) {
                let count = this.missileLevel * 2; // 2, 4, 6
                for(let i=0; i<count; i++) {
                    let dir = (i % 2 === 0) ? -1 : 1;
                    let speedX = dir * (2 + Math.floor(i/2));
                    bullets.push(new Missile(this.x + speedX*5, this.y, speedX, -4));
                }
            }
        }
        draw() {
            if (this.invincible > 0 && Math.floor(Date.now() / 50) % 2 === 0) return;
            drawSprite(ctx, SPRITES.PLAYER, this.x, this.y, ['#ecf0f1', '#e74c3c'], 1.5);
            if (this.shield) {
                ctx.strokeStyle = '#3498db'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(this.x, this.y, 25, 0, Math.PI*2); ctx.stroke();
            }
        }
    }

    class Bullet {
        constructor(x, y, vx, vy, owner, type) {
            this.x = x; this.y = y; this.vx = vx; this.vy = vy;
            this.owner = owner; this.type = type; this.active = true;
        }
        update() {
            this.x += this.vx; this.y += this.vy;
            // ÈÇäÁïåÊ™¢Êü•
            if (this.x < -20 || this.x > GAME_WIDTH + 20 || this.y < -20 || this.y > GAME_HEIGHT + 20) this.active = false;
        }
        draw() {
            if (this.owner === 'PLAYER') {
                if (this.type === 'LASER') drawSprite(ctx, SPRITES.BULLET_LASER, this.x, this.y, ['#9b59b6', '#fff'], 2.0);
                else drawSprite(ctx, SPRITES.BULLET_P, this.x, this.y, ['#f1c40f', '#fff'], 1.2);
            } else {
                drawSprite(ctx, SPRITES.BULLET_E, this.x, this.y, ['#e74c3c', '#fff'], 1.2);
            }
        }
    }

    class Missile extends Bullet {
        constructor(x, y, vx, vy) {
            super(x, y, vx, vy, 'PLAYER', 'MISSILE');
            this.target = null;
            this.speed = 7;
            this.life = 100; // Â£ΩÂëΩÈôêÂà∂
        }
        update() {
            this.life--;
            if (this.life <= 0) this.active = false;

            if (!this.target || !this.target.active) {
                this.target = null;
                // Â∞ãÊâæÊúÄËøëÊïµ‰∫∫
                let minDist = 9999;
                if(bossActive && boss && boss.active) this.target = boss;
                else {
                    for(let e of enemies) {
                        if(e.active) {
                            let d = Math.abs(e.x - this.x) + Math.abs(e.y - this.y); // Áî®ÊõºÂìàÈ†ìË∑ùÈõ¢‰ª£ÊõøÂπ≥ÊñπÊ†πÔºåÊõ¥Âø´
                            if(d < minDist) { minDist = d; this.target = e; }
                        }
                    }
                }
            }

            if (this.target && this.target.active) {
                const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                // Á∞°ÂñÆËøΩËπ§Ôºå‰∏ç‰ΩøÁî® lerp ÈÅøÂÖçË§áÈõúÈÅãÁÆó
                this.vx = this.vx * 0.9 + Math.cos(angle) * 1.5;
                this.vy = this.vy * 0.9 + Math.sin(angle) * 1.5;
                
                // ÈÄüÂ∫¶Ê≠∏‰∏ÄÂåñ (Ëøë‰ºº)
                const len = Math.abs(this.vx) + Math.abs(this.vy);
                if(len > 0) {
                    this.vx = (this.vx / len) * this.speed;
                    this.vy = (this.vy / len) * this.speed;
                }
            }

            this.x += this.vx; this.y += this.vy;
            if (frameCount % 5 === 0) particles.push(new Particle(this.x, this.y, '#bdc3c7', 0, 1, 5));
            if (this.x < -50 || this.x > GAME_WIDTH+50 || this.y < -50 || this.y > GAME_HEIGHT+50) this.active = false;
        }
        draw() {
            drawSprite(ctx, SPRITES.BULLET_MISSILE, this.x, this.y, ['#3498db', '#fff'], 1.5, Math.atan2(this.vy, this.vx)+Math.PI/2);
        }
    }

    class Boss {
        constructor() {
            this.x = GAME_WIDTH / 2; this.y = -50; this.w = 80; this.h = 40;
            this.maxHp = 300 * Math.pow(1.8, (bossLevel-1)); 
            this.hp = this.maxHp;
            this.active = true;
            this.phase = 'ENTER'; this.timer = 0; this.moveDir = 1; this.flashTimer = 0;
        }
        update() {
            this.timer++;
            if (this.flashTimer > 0) this.flashTimer--;

            if (this.phase === 'ENTER') {
                this.y += 1; if (this.y >= 80) this.phase = 'FIGHT';
            } 
            else if (this.phase === 'FIGHT') {
                this.x += this.moveDir * 1.5;
                if (this.x > GAME_WIDTH - 50 || this.x < 50) this.moveDir *= -1;

                if (this.timer % 60 === 0) { 
                    for (let i = -2; i <= 2; i++) bullets.push(new Bullet(this.x, this.y + 20, i * 2, 4, 'ENEMY', 'NORMAL'));
                }
                if (this.timer % 150 === 0) {
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    bullets.push(new Bullet(this.x, this.y + 20, Math.cos(angle)*5, Math.sin(angle)*5, 'ENEMY', 'NORMAL'));
                }
            } 
            else if (this.phase === 'DYING') {
                if (this.timer % 10 === 0) createExplosion(this.x + (Math.random()-0.5)*80, this.y + (Math.random()-0.5)*40);
                if (this.timer > 120) {
                    this.active = false; bossActive = false;
                    score += 5000; nextBossScore += BOSS_INTERVAL; bossLevel++;
                    difficultyMultiplier = 1.0 + (bossLevel - 1) * 0.15; // Èõ£Â∫¶Â¢ûÂä†
                    updateUI();
                    
                    // ÊéâËêΩ
                    powerups.push(new PowerUp(this.x, this.y, 'HEART'));
                    powerups.push(new PowerUp(this.x-30, this.y, 'BOMB'));
                    powerups.push(new PowerUp(this.x+30, this.y, 'LASER'));
                    
                    ui.bossHud.style.display = 'none';
                }
            }
        }
        draw() {
            if (this.flashTimer > 0) { ctx.globalCompositeOperation = 'source-atop'; ctx.fillStyle = 'white'; }
            drawSprite(ctx, SPRITES.BOSS, this.x, this.y, ['#95a5a6', '#7f8c8d', '#e74c3c', '#f1c40f'], 3.0);
            ctx.globalCompositeOperation = 'source-over';
        }
        hit(damage) {
            if (this.phase !== 'FIGHT') return;
            this.hp -= damage; this.flashTimer = 3;
            ui.bossHpFill.style.width = (Math.max(0, this.hp / this.maxHp) * 100) + '%';
            if (this.hp <= 0) {
                this.phase = 'DYING'; this.timer = 0; playSound('BOMB');
                bullets.forEach(b => { if (b.owner === 'ENEMY') b.active = false; });
            }
        }
    }

    class Enemy {
        constructor(type) {
            this.type = type; this.active = true;
            this.x = Math.random() * (GAME_WIDTH - 40) + 20;
            this.y = -30; this.hp = 1; this.timer = 0;
            if (type === 'SMALL') {
                this.vy = (3 + Math.random() * 2) * difficultyMultiplier; 
                this.vx = (Math.random() - 0.5) * 1;
                this.colors = ['#95a5a6', '#7f8c8d'];
            } else if (type === 'SHOOTER') {
                this.vy = 1.5 * difficultyMultiplier; this.vx = 0; this.hp = 3;
                this.colors = ['#2ecc71', '#27ae60'];
            }
        }
        update() {
            this.y += this.vy; this.x += this.vx; this.timer++;
            if (this.type === 'SHOOTER') {
                this.x += Math.sin(this.timer * 0.05) * 1;
                if (this.timer % Math.floor(100/difficultyMultiplier) === 50) {
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    bullets.push(new Bullet(this.x, this.y, Math.cos(angle)*3, Math.sin(angle)*3, 'ENEMY', 'NORMAL'));
                }
            }
            if (this.y > GAME_HEIGHT + 30) this.active = false;
        }
        draw() {
            const sprite = this.type === 'SMALL' ? SPRITES.ENEMY_SMALL : SPRITES.ENEMY_SHOOTER;
            drawSprite(ctx, sprite, this.x, this.y, this.colors, 1.5);
        }
        hit(damage = 1) {
            this.hp -= damage;
            if (this.hp <= 0) {
                this.active = false; createExplosion(this.x, this.y);
                score += (this.type === 'SMALL' ? 200 : 500);
                // ÊéâËêΩ
                if (Math.random() < 0.1) {
                    const rand = Math.random();
                    let dropType;
                    // Ê†πÊìöÈúÄÊ±ÇÊô∫ËÉΩÊéâËêΩ
                    if (player.weapon === 'DOUBLE' && Math.random() < 0.3) dropType = 'DOUBLE';
                    else {
                        if (rand < 0.25) dropType = 'DOUBLE';
                        else if (rand < 0.45) dropType = 'MISSILE';
                        else if (rand < 0.65) dropType = 'SPREAD';
                        else if (rand < 0.8) dropType = 'LASER';
                        else if (rand < 0.85) dropType = 'SHIELD';
                        else if (rand < 0.9) dropType = 'BOMB';
                        else dropType = 'HEART';
                    }
                    powerups.push(new PowerUp(this.x, this.y, dropType));
                }
            } else {
                ctx.globalCompositeOperation = 'source-atop'; ctx.fillStyle = 'white';
                ctx.fillRect(this.x-12, this.y-12, 24, 24); ctx.globalCompositeOperation = 'source-over';
            }
        }
    }

    class PowerUp {
        constructor(x, y, type) {
            this.x = x; this.y = y; this.type = type; this.active = true; this.vy = 1.5;
        }
        update() {
            this.y += this.vy; this.x += Math.sin(this.y * 0.05) * 0.5;
            if (this.y > GAME_HEIGHT) this.active = false;
        }
        draw() {
            let sprite, colors;
            switch(this.type) {
                case 'DOUBLE': sprite = SPRITES.ITEM_DOUBLE; colors = ['#f1c40f', '#fff']; break;
                case 'MISSILE': sprite = SPRITES.ITEM_MISSILE; colors = ['#3498db', '#fff']; break;
                case 'LASER':  sprite = SPRITES.ITEM_LASER;  colors = ['#9b59b6', '#fff']; break;
                case 'BOMB':   sprite = SPRITES.ITEM_BOMB;   colors = ['#e74c3c', '#fff']; break;
                case 'SHIELD': sprite = SPRITES.ITEM_SHIELD; colors = ['#3498db', '#fff']; break;
                case 'HEART':  sprite = SPRITES.ITEM_HEART;  colors = ['#ff6b81', '#fff']; break;
                case 'SPREAD': sprite = SPRITES.ITEM_SPREAD; colors = ['#2ecc71', '#fff']; break;
                default: sprite = SPRITES.ITEM_DOUBLE; colors = ['#f1c40f', '#fff'];
            }
            drawSprite(ctx, sprite, this.x, this.y, colors, 1.5);
        }
    }

    class Particle {
        constructor(x, y, color, speed, life) {
            this.x = x; this.y = y; this.color = color;
            this.vx = (Math.random() - 0.5) * speed; this.vy = (Math.random() - 0.5) * speed;
            this.life = life; this.maxLife = life; this.size = Math.random() * 3 + 2;
        }
        update() { this.x += this.vx; this.y += this.vy; this.life--; }
        draw() {
            ctx.globalAlpha = this.life / this.maxLife; ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, this.size, this.size); ctx.globalAlpha = 1;
        }
    }

    class Cloud {
        constructor(y) {
            this.x = Math.random() * GAME_WIDTH; this.y = y;
            this.speed = 0.5 + Math.random() * 0.5; this.size = 20 + Math.random() * 40; this.alpha = 0.1 + Math.random() * 0.2;
        }
        update() {
            this.y += this.speed; if (this.y > GAME_HEIGHT + 50) { this.y = -50; this.x = Math.random() * GAME_WIDTH; }
        }
        draw() {
            ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha})`; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
        }
    }

    // --- 5. ÈÅäÊà≤‰∏ªÂæ™Áí∞ ---
    
    function createExplosion(x, y) {
        playSound('EXPLODE');
        if (particles.length > 100) return; // ‚òÖ Âö¥Ê†ºÈôêÂà∂ÁàÜÁÇ∏Á≤íÂ≠êÊï∏
        for(let i=0; i<6; i++) {
            particles.push(new Particle(x, y, '#e67e22', 4, 15 + Math.random()*10));
        }
    }

    function spawnBossTrigger() {
        bossActive = true;
        ui.warningOverlay.classList.add('flash-anim');
        ui.warningText.style.display = 'block';
        playSound('ALARM');
        setTimeout(() => {
            ui.warningOverlay.classList.remove('flash-anim');
            ui.warningText.style.display = 'none';
            boss = new Boss();
            ui.bossHud.style.display = 'flex';
            ui.bossHpFill.style.width = '100%';
        }, 3000); 
    }

    function spawnEnemy() {
        if (bossActive) return;
        if (score >= nextBossScore) { spawnBossTrigger(); return; }
        
        const spawnRate = Math.max(20, Math.floor(60 / difficultyMultiplier));
        if (frameCount % spawnRate === 0) {
            const rand = Math.random();
            if (rand < 0.7) enemies.push(new Enemy('SMALL'));
            else enemies.push(new Enemy('SHOOTER'));
        }
    }

    function activateBomb() {
        playSound('BOMB');
        ui.flashOverlay.style.opacity = 1;
        setTimeout(() => ui.flashOverlay.style.opacity = 0, 200);
        enemies.forEach(e => {
            if (e.active) { e.hp = 0; e.active = false; score += 500; createExplosion(e.x, e.y); }
        });
        bullets.forEach(b => { if (b.owner === 'ENEMY') b.active = false; });
        if (boss && boss.active && boss.phase === 'FIGHT') boss.hit(50);
    }

    function checkCollisions() {
        const hit = (a, b, dist) => Math.abs(a.x - b.x) < dist && Math.abs(a.y - b.y) < dist;

        bullets.forEach(b => {
            if (!b.active || b.owner !== 'PLAYER') return;
            enemies.forEach(e => {
                if (!e.active) return;
                if (hit(b, e, 18)) {
                    if (b.type !== 'LASER') b.active = false;
                    let dmg = (b.type === 'LASER') ? 3 : (b.type === 'MISSILE' ? 2 : 1);
                    e.hit(dmg);
                    if(particles.length < 100) particles.push(new Particle(b.x, b.y, '#fff', 2, 5));
                }
            });
            if (boss && boss.active && boss.phase === 'FIGHT' && hit(b, boss, 40)) {
                if (b.type !== 'LASER') b.active = false;
                let dmg = (b.type === 'LASER') ? 3 : (b.type === 'MISSILE' ? 2 : 1);
                boss.hit(dmg);
                if(particles.length < 100) particles.push(new Particle(b.x, b.y, '#fff', 2, 5));
            }
        });

        powerups.forEach(p => {
            if (!p.active) return;
            if (hit(p, player, 20)) {
                p.active = false;
                playSound('POWERUP');
                let txt = "";
                if (p.type === 'BOMB') { activateBomb(); txt = "BOMB!!"; }
                else if (p.type === 'SHIELD') { player.shield = true; txt = "SHIELD"; }
                else if (p.type === 'HEART') { if (lives < 5) lives++; txt = "HP +1"; }
                else if (p.type === 'MISSILE') {
                    player.missileLevel = Math.min(3, player.missileLevel + 1);
                    txt = `MISSILE Lv${player.missileLevel}`;
                } else {
                    if (player.weapon === p.type) {
                        player.weaponLevel = Math.min(3, player.weaponLevel + 1);
                        txt = "LEVEL UP";
                    } else {
                        player.weapon = p.type; player.weaponLevel = 1;
                        txt = p.type;
                    }
                }
                textPopups.push(new FloatingText(player.x, player.y - 30, txt, "#fff"));
                score += 200; updateUI();
            }
        });

        if (player.invincible <= 0) {
            let getHit = false;
            enemies.forEach(e => { if (e.active && hit(player, e, 18)) { e.active = false; createExplosion(e.x, e.y); getHit = true; } });
            bullets.forEach(b => { if (b.active && b.owner === 'ENEMY' && hit(player, b, 10)) { b.active = false; getHit = true; } });
            if (boss && boss.active && boss.phase === 'FIGHT' && hit(player, boss, 40)) getHit = true;

            if (getHit) {
                if (player.shield) {
                    player.shield = false; player.invincible = 60; playSound('EXPLODE');
                    textPopups.push(new FloatingText(player.x, player.y - 30, "SHIELD LOST", "#3498db"));
                } else {
                    takeDamage();
                }
            }
        }
    }

    function takeDamage() {
        lives--;
        createExplosion(player.x, player.y);
        player.invincible = 120;
        player.weaponLevel = Math.max(1, player.weaponLevel - 1);
        player.missileLevel = Math.max(0, player.missileLevel - 1);
        updateUI();
        if (lives <= 0) gameOver();
    }

    function updateUI() {
        ui.score.innerText = score;
        let hearts = ''; for(let i=0; i<lives; i++) hearts += '‚ù§Ô∏è';
        ui.lives.innerHTML = hearts;
        
        const wName = player.weapon === 'DEFAULT' ? 'NORMAL' : player.weapon;
        const wLvl = player.weaponLevel === 3 ? 'MAX' : `LV.${player.weaponLevel}`;
        ui.weapon.innerText = `MAIN: ${wName} (${wLvl})`;
        const mLvl = player.missileLevel === 0 ? 'NONE' : `LV.${player.missileLevel}`;
        ui.subWeapon.innerText = `SUB: MISSILE (${mLvl})`;
        ui.diff.innerText = `THREAT: ${Math.floor(difficultyMultiplier*100)}%`;
    }

    function gameOver() {
        gameState = 'GAMEOVER';
        ui.gameOverUi.style.display = 'flex';
        ui.startScreen.style.display = 'flex';
        ui.mainMenu.style.display = 'none';
        ui.finalScore.innerText = score;
        ui.bossHud.style.display = 'none';
    }

    function startGame() {
        player = new Player();
        bullets = []; enemies = []; particles = []; powerups = []; textPopups = [];
        score = 0; lives = 3; frameCount = 0;
        bossActive = false; nextBossScore = 20000; boss = null; bossLevel = 1; difficultyMultiplier = 1.0;
        ui.bossHud.style.display = 'none';
        clouds = []; for(let i=0; i<10; i++) clouds.push(new Cloud(Math.random() * GAME_HEIGHT));
        updateUI();
        ui.startScreen.style.display = 'none';
        initAudio();
        gameState = 'PLAYING';
        loop();
    }

    function loop() {
        if (gameState !== 'PLAYING') return;
        ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        frameCount++;

        clouds.forEach(c => { c.update(); c.draw(); });
        player.update(); player.draw();
        
        spawnEnemy();
        if (boss && boss.active) { boss.update(); boss.draw(); }
        
        enemies.forEach(e => { e.update(); e.draw(); });
        bullets.forEach(b => { b.update(); b.draw(); });
        powerups.forEach(p => { p.update(); p.draw(); });
        particles.forEach(p => { p.update(); p.draw(); });
        textPopups.forEach(t => { t.update(); t.draw(ctx); });

        // Áâ©‰ª∂Ê±†Ê∏ÖÁêÜ (ÊúÄÈóúÈçµÁöÑÈò≤Áï∂Ê©üÊ≠•È©ü)
        bullets = bullets.filter(b => b.active);
        enemies = enemies.filter(e => e.active);
        powerups = powerups.filter(p => p.active);
        textPopups = textPopups.filter(t => t.life > 0);
        
        // ‚òÖ Âº∑Âà∂ÁßªÈô§Â§öÈ§òÁ≤íÂ≠ê
        if (particles.length > 100) particles.splice(0, particles.length - 100);
        particles = particles.filter(p => p.life > 0);

        checkCollisions();
        if (frameCount % 10 === 0) ui.score.innerText = score;

        requestAnimationFrame(loop);
    }

    function handleInput(e) {
        if (gameState !== 'PLAYING') return;
        const rect = canvas.getBoundingClientRect();
        const scaleX = GAME_WIDTH / rect.width;
        const scaleY = GAME_HEIGHT / rect.height;
        let clientX = e.touches ? e.touches[0].clientX : e.clientX;
        let clientY = e.touches ? e.touches[0].clientY : e.clientY;
        input.x = (clientX - rect.left) * scaleX;
        input.y = (clientY - rect.top) * scaleY;
        input.active = true;
    }
    function stopInput() { input.active = false; }

    const stage = document.getElementById('game-stage');
    stage.addEventListener('mousemove', handleInput);
    stage.addEventListener('touchmove', handleInput, {passive: false});
    stage.addEventListener('touchstart', handleInput, {passive: false});
    stage.addEventListener('touchend', stopInput);

</script>
</body>
</html>
