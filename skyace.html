<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SKY ACE 1945 | åƒç´ ç©ºæˆ°</title>
    <style>
        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            background: #111; overflow: hidden; 
            font-family: 'Courier New', monospace;
            touch-action: none; user-select: none; -webkit-user-select: none;
        }

        #game-stage {
            position: relative; width: 100%; height: 100%; max-width: 600px; margin: 0 auto;
            background: #004477; /* æ·±æµ·è—èƒŒæ™¯ */
            overflow: hidden;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }

        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }

        /* CRT å¾©å¤æƒæç·šç‰¹æ•ˆ */
        #scanlines {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 4px, 6px 100%;
            pointer-events: none; z-index: 10;
        }

        /* UI å±¤ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 20;
            padding: 20px; box-sizing: border-box;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        .hud-top { display: flex; justify-content: space-between; color: #fff; text-shadow: 2px 2px 0 #000; }
        .score-box { font-size: 24px; font-weight: bold; }
        .life-box { font-size: 24px; color: #ff3b30; }

        /* é–‹å§‹ç•«é¢ */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #fff; text-align: center;
        }
        
        .title { font-size: 48px; color: #f1c40f; text-shadow: 4px 4px 0 #c0392b; margin-bottom: 20px; font-weight: 900; letter-spacing: 5px; }
        .blink { animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0; } }
        
        .btn {
            background: #c0392b; color: #fff; border: 4px solid #fff;
            padding: 15px 40px; font-size: 24px; font-weight: bold; font-family: inherit;
            cursor: pointer; text-transform: uppercase; margin-top: 20px;
            box-shadow: 0 10px 0 #7f261c; transition: transform 0.1s, box-shadow 0.1s;
        }
        .btn:active { transform: translateY(5px); box-shadow: 0 5px 0 #7f261c; }

        /* éŠæˆ²çµæŸ */
        #game-over-ui { display: none; flex-direction: column; align-items: center; }

        /* è¿”å›é¦–é  */
        .home-btn {
            position: fixed; top: 15px; left: 15px; z-index: 200; pointer-events: auto;
            text-decoration: none; font-size: 24px; width: 40px; height: 40px;
            background: rgba(0,0,0,0.5); border: 2px solid #fff; border-radius: 5px;
            display: flex; align-items: center; justify-content: center; color: #fff;
        }
    </style>
</head>
<body>

<a href="index.html" class="home-btn">ğŸ </a>

<div id="game-stage">
    <canvas id="gameCanvas"></canvas>
    <div id="scanlines"></div>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="score-box">SCORE: <span id="score">0</span></div>
            <div class="life-box" id="lives">â¤ï¸â¤ï¸â¤ï¸</div>
        </div>
    </div>

    <div id="start-screen">
        <div id="main-menu">
            <div class="title">SKY ACE<br>1945</div>
            <p class="blink">INSERT COIN TO START</p>
            <button class="btn" onclick="startGame()">MISSION START</button>
            <p style="margin-top: 20px; font-size: 12px; color: #aaa;">DRAG TO MOVE â€¢ AUTO FIRE</p>
        </div>

        <div id="game-over-ui">
            <div class="title" style="color: #ff3b30;">MISSION FAILED</div>
            <div style="font-size: 24px; margin-bottom: 20px;">FINAL SCORE: <span id="final-score">0</span></div>
            <button class="btn" onclick="startGame()">TRY AGAIN</button>
        </div>
    </div>
</div>

<script>
    /** ================= 1. å¼•æ“èˆ‡è¨­å®š (Engine Setup) ================= **/
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // éŠæˆ²è§£æåº¦ (ä½è§£æåº¦åƒç´ é¢¨ï¼Œè‡ªå‹•æ‹‰ä¼¸)
    const GAME_WIDTH = 300;
    const GAME_HEIGHT = 500;
    
    // ç‹€æ…‹
    let gameState = 'MENU';
    let score = 0;
    let lives = 3;
    let frameCount = 0;
    
    // è¼¸å…¥ç‹€æ…‹
    let input = { x: GAME_WIDTH / 2, y: GAME_HEIGHT - 50, active: false };
    
    // å¯¦é«”æ± 
    let player;
    let bullets = [];
    let enemies = [];
    let particles = [];
    let powerups = [];
    let clouds = [];

    // ä½åœ–æ•¸æ“š (1=Color, 0=Transparent)
    // ç°¡å–®çš„ 8x8 æˆ– 10x10 åƒç´ åœ–
    const SPRITES = {
        PLAYER: [
            [0,0,0,1,0,0,0],
            [0,0,1,1,1,0,0],
            [0,1,1,2,1,1,0],
            [1,1,1,2,1,1,1],
            [1,0,1,2,1,0,1],
            [0,0,1,2,1,0,0],
            [0,1,1,0,1,1,0]
        ],
        ENEMY_SMALL: [ // è‡ªæ®ºæ©Ÿ
            [0,0,1,1,1,0,0],
            [0,1,1,1,1,1,0],
            [1,1,0,1,0,1,1],
            [0,0,0,1,0,0,0],
            [0,0,1,0,1,0,0]
        ],
        ENEMY_SHOOTER: [ // å°„æ“Šæ©Ÿ
            [0,1,0,0,0,1,0],
            [1,1,1,1,1,1,1],
            [0,1,1,2,1,1,0],
            [0,0,1,2,1,0,0],
            [0,0,0,1,0,0,0]
        ],
        BULLET_P: [ // ç©å®¶å­å½ˆ
            [1,2],
            [1,2],
            [1,2]
        ],
        BULLET_E: [ // æ•µäººå­å½ˆ
            [2,1,2],
            [1,1,1],
            [2,1,2]
        ],
        POWERUP: [
            [1,1,1,1,1],
            [1,2,2,2,1],
            [1,2,1,2,1], // P letter roughly
            [1,2,2,2,1],
            [1,2,0,0,0],
            [1,2,0,0,0]
        ]
    };

    /** ================= 2. æ¸²æŸ“å¼•æ“ (Renderer) ================= **/
    function resize() {
        const stage = document.getElementById('game-stage');
        const ratio = stage.clientHeight / stage.clientWidth;
        
        // ä¿æŒæ¯”ä¾‹
        canvas.width = GAME_WIDTH;
        canvas.height = GAME_HEIGHT;
        
        // CSS æœƒè™•ç†æ‹‰ä¼¸ï¼Œé€™è£¡åªéœ€è¦ç¢ºä¿å…§éƒ¨é‚è¼¯è§£æåº¦å›ºå®š
    }
    window.addEventListener('resize', resize);
    resize();

    // ç¹ªè£½åƒç´ åœ–
    function drawSprite(ctx, sprite, cx, cy, colors) {
        const rows = sprite.length;
        const cols = sprite[0].length;
        const pixelSize = 2; // æ¯å€‹åƒç´ æ”¾å¤§2å€
        const w = cols * pixelSize;
        const h = rows * pixelSize;
        const startX = cx - w / 2;
        const startY = cy - h / 2;

        for(let r=0; r<rows; r++) {
            for(let c=0; c<cols; c++) {
                const val = sprite[r][c];
                if (val > 0) {
                    ctx.fillStyle = colors[val-1]; // 1=colors[0], 2=colors[1]
                    ctx.fillRect(startX + c*pixelSize, startY + r*pixelSize, pixelSize, pixelSize);
                }
            }
        }
        return { w, h };
    }

    /** ================= 3. éŸ³æ•ˆåˆæˆ (Audio Synth) ================= **/
    let audioCtx;
    function initAudio() {
        if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if(audioCtx.state === 'suspended') audioCtx.resume();
    }

    function playSound(type) {
        if(!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const now = audioCtx.currentTime;

        if (type === 'SHOOT') {
            // ç©å®¶å°„æ“Šï¼šå¿«é€Ÿè„ˆè¡
            osc.type = 'square';
            osc.frequency.setValueAtTime(800, now);
            osc.frequency.exponentialRampToValueAtTime(300, now + 0.1);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(now + 0.1);
        } 
        else if (type === 'ENEMY_SHOOT') {
            // æ•µäººå°„æ“Š
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(200, now);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(now + 0.15);
        }
        else if (type === 'EXPLODE') {
            // çˆ†ç‚¸ï¼šç™½å™ªéŸ³
            const bufferSize = audioCtx.sampleRate * 0.5;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            
            // ä½é€šæ¿¾æ³¢
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(1000, now);
            filter.frequency.linearRampToValueAtTime(100, now + 0.3);

            gain.gain.setValueAtTime(0.5, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);

            noise.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);
            noise.start();
        }
        else if (type === 'POWERUP') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(400, now);
            osc.frequency.linearRampToValueAtTime(1200, now + 0.3);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.3);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(now + 0.3);
        }
    }

    /** ================= 4. éŠæˆ²ç‰©ä»¶ (Game Objects) ================= **/
    
    class Player {
        constructor() {
            this.x = GAME_WIDTH / 2;
            this.y = GAME_HEIGHT - 80;
            this.w = 14; 
            this.h = 14;
            this.level = 1; // ç«åŠ›ç­‰ç´š
            this.shootTimer = 0;
            this.invincible = 0;
        }
        update() {
            // å¹³æ»‘ç§»å‹• (Lerp) - æ¨¡æ“¬æ…£æ€§
            // å¦‚æœæœ‰è¼¸å…¥ï¼Œé£›å‘è¼¸å…¥é» (ç¨å¾®å‘ä¸Šåç§»ä¸€é»ï¼Œå› ç‚ºæ‰‹æŒ‡æœƒé®ä½é£›æ©Ÿ)
            if (input.active) {
                const targetY = input.y - 30; 
                this.x += (input.x - this.x) * 0.15;
                this.y += (targetY - this.y) * 0.15;
            }

            // é‚Šç•Œé™åˆ¶
            this.x = Math.max(10, Math.min(GAME_WIDTH - 10, this.x));
            this.y = Math.max(10, Math.min(GAME_HEIGHT - 10, this.y));

            // è‡ªå‹•å°„æ“Š
            this.shootTimer++;
            if (this.shootTimer > 8) { // å°„é€Ÿ
                this.shoot();
                this.shootTimer = 0;
            }

            if (this.invincible > 0) this.invincible--;
        }
        shoot() {
            playSound('SHOOT');
            if (this.level === 1) {
                bullets.push(new Bullet(this.x, this.y - 10, 0, -8, 'PLAYER'));
            } else {
                // é›™æ’ç«åŠ›
                bullets.push(new Bullet(this.x - 5, this.y - 10, 0, -8, 'PLAYER'));
                bullets.push(new Bullet(this.x + 5, this.y - 10, 0, -8, 'PLAYER'));
            }
        }
        draw() {
            if (this.invincible > 0 && Math.floor(Date.now() / 50) % 2 === 0) return; // é–ƒçˆ
            // é£›æ©Ÿé¡è‰²ï¼šç™½èº«ã€ç´…è‰™
            drawSprite(ctx, SPRITES.PLAYER, this.x, this.y, ['#ecf0f1', '#e74c3c']);
            
            // å™´å°„ç«ç„°ç‰¹æ•ˆ
            if (Math.random() < 0.5) {
                particles.push(new Particle(this.x, this.y + 10, '#f1c40f', 0, 2, 10));
            }
        }
    }

    class Bullet {
        constructor(x, y, vx, vy, owner) {
            this.x = x; this.y = y; this.vx = vx; this.vy = vy;
            this.owner = owner;
            this.active = true;
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            // å‡ºç•Œç§»é™¤
            if (this.x < 0 || this.x > GAME_WIDTH || this.y < 0 || this.y > GAME_HEIGHT) this.active = false;
        }
        draw() {
            if (this.owner === 'PLAYER') {
                drawSprite(ctx, SPRITES.BULLET_P, this.x, this.y, ['#f1c40f', '#fff']);
            } else {
                drawSprite(ctx, SPRITES.BULLET_E, this.x, this.y, ['#e74c3c', '#fff']);
            }
        }
    }

    class Enemy {
        constructor(type) {
            this.type = type;
            this.active = true;
            this.x = Math.random() * (GAME_WIDTH - 20) + 10;
            this.y = -20;
            this.hp = 1;
            this.timer = 0;

            if (type === 'SMALL') {
                this.vy = 3 + Math.random() * 2; // å¿«é€Ÿè¡åˆº
                this.vx = (Math.random() - 0.5) * 1;
                this.colors = ['#95a5a6', '#7f8c8d'];
            } else if (type === 'SHOOTER') {
                this.vy = 1.5;
                this.vx = 0;
                this.hp = 3;
                this.colors = ['#2ecc71', '#27ae60'];
            }
        }
        update() {
            this.y += this.vy;
            this.x += this.vx;
            this.timer++;

            // AI è¡Œç‚º
            if (this.type === 'SHOOTER') {
                // æ™ƒå‹•
                this.x += Math.sin(this.timer * 0.05) * 1;
                
                // å°„æ“Š
                if (this.timer % 100 === 50) {
                    playSound('ENEMY_SHOOT');
                    // ç„æº–ç©å®¶
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    const speed = 4;
                    bullets.push(new Bullet(this.x, this.y, Math.cos(angle)*speed, Math.sin(angle)*speed, 'ENEMY'));
                }
            }

            if (this.y > GAME_HEIGHT + 20) this.active = false;
        }
        draw() {
            const sprite = this.type === 'SMALL' ? SPRITES.ENEMY_SMALL : SPRITES.ENEMY_SHOOTER;
            drawSprite(ctx, sprite, this.x, this.y, this.colors);
        }
        hit() {
            this.hp--;
            if (this.hp <= 0) {
                this.active = false;
                createExplosion(this.x, this.y);
                score += (this.type === 'SMALL' ? 100 : 300);
                
                // æ‰è½é“å…· (5% æ©Ÿç‡)
                if (Math.random() < 0.05) {
                    powerups.push(new PowerUp(this.x, this.y));
                }
            } else {
                // å—å‚·é–ƒç™½
                ctx.globalCompositeOperation = 'source-atop';
                ctx.fillStyle = 'white';
                ctx.fillRect(this.x-8, this.y-8, 16, 16);
                ctx.globalCompositeOperation = 'source-over';
            }
        }
    }

    class PowerUp {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.active = true;
            this.vy = 1;
        }
        update() {
            this.y += this.vy;
            // å·¦å³é£„
            this.x += Math.sin(this.y * 0.05);
            if (this.y > GAME_HEIGHT) this.active = false;
        }
        draw() {
            drawSprite(ctx, SPRITES.POWERUP, this.x, this.y, ['#3498db', '#fff']);
        }
    }

    class Particle {
        constructor(x, y, color, speed, life) {
            this.x = x; this.y = y; this.color = color;
            this.vx = (Math.random() - 0.5) * speed;
            this.vy = (Math.random() - 0.5) * speed;
            this.life = life;
            this.maxLife = life;
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life--;
        }
        draw() {
            ctx.globalAlpha = this.life / this.maxLife;
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, 2, 2);
            ctx.globalAlpha = 1;
        }
    }

    class Cloud {
        constructor(y) {
            this.x = Math.random() * GAME_WIDTH;
            this.y = y;
            this.speed = 0.5 + Math.random() * 0.5;
            this.size = 20 + Math.random() * 40;
            this.alpha = 0.1 + Math.random() * 0.2;
        }
        update() {
            this.y += this.speed;
            if (this.y > GAME_HEIGHT + 50) {
                this.y = -50;
                this.x = Math.random() * GAME_WIDTH;
            }
        }
        draw() {
            ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
            ctx.fill();
        }
    }

    /** ================= 5. éŠæˆ²é‚è¼¯ (Game Logic) ================= **/
    
    function createExplosion(x, y) {
        playSound('EXPLODE');
        for(let i=0; i<15; i++) {
            particles.push(new Particle(x, y, '#e67e22', 4, 20 + Math.random()*10));
            particles.push(new Particle(x, y, '#f1c40f', 3, 10 + Math.random()*10));
        }
    }

    function spawnEnemy() {
        if (frameCount % 60 === 0) { // æ¯ç§’ä¸€éš»
            const rand = Math.random();
            if (rand < 0.7) enemies.push(new Enemy('SMALL'));
            else enemies.push(new Enemy('SHOOTER'));
        }
    }

    function checkCollisions() {
        // çŸ©å½¢ç¢°æ’æª¢æ¸¬
        const hit = (a, b, dist) => {
            return Math.abs(a.x - b.x) < dist && Math.abs(a.y - b.y) < dist;
        };

        // å­å½ˆæ‰“æ•µäºº
        bullets.forEach(b => {
            if (!b.active || b.owner !== 'PLAYER') return;
            enemies.forEach(e => {
                if (!e.active) return;
                if (hit(b, e, 12)) {
                    b.active = false;
                    e.hit();
                    // å°ç«èŠ±
                    particles.push(new Particle(b.x, b.y, '#fff', 2, 5));
                }
            });
        });

        // ç©å®¶åƒé“å…·
        powerups.forEach(p => {
            if (!p.active) return;
            if (hit(p, player, 15)) {
                p.active = false;
                player.level = 2;
                playSound('POWERUP');
                score += 500;
            }
        });

        // ç©å®¶å—å‚· (æ’æ©Ÿæˆ–ä¸­å½ˆ)
        if (player.invincible <= 0) {
            // æ’æ•µæ©Ÿ
            enemies.forEach(e => {
                if (e.active && hit(player, e, 12)) {
                    e.active = false;
                    createExplosion(e.x, e.y);
                    takeDamage();
                }
            });
            // ä¸­å­å½ˆ
            bullets.forEach(b => {
                if (b.active && b.owner === 'ENEMY' && hit(player, b, 8)) {
                    b.active = false;
                    takeDamage();
                }
            });
        }
    }

    function takeDamage() {
        lives--;
        createExplosion(player.x, player.y);
        player.invincible = 120; // 2ç§’ç„¡æ•µ
        player.level = 1; // æ‰è£
        updateUI();
        
        if (lives <= 0) {
            gameOver();
        }
    }

    function updateUI() {
        document.getElementById('score').innerText = score;
        let hearts = '';
        for(let i=0; i<lives; i++) hearts += 'â¤ï¸';
        document.getElementById('lives').innerHTML = hearts;
    }

    function gameOver() {
        gameState = 'GAMEOVER';
        document.getElementById('game-over-ui').style.display = 'flex';
        document.getElementById('start-screen').style.display = 'flex';
        document.getElementById('main-menu').style.display = 'none';
        document.getElementById('final-score').innerText = score;
    }

    function startGame() {
        // é‡ç½®
        player = new Player();
        bullets = [];
        enemies = [];
        particles = [];
        powerups = [];
        score = 0;
        lives = 3;
        frameCount = 0;
        
        // åˆå§‹é›²
        clouds = [];
        for(let i=0; i<10; i++) clouds.push(new Cloud(Math.random() * GAME_HEIGHT));

        updateUI();
        
        document.getElementById('start-screen').style.display = 'none';
        
        initAudio();
        gameState = 'PLAYING';
        loop();
    }

    // --- ä¸»å¾ªç’° ---
    function loop() {
        if (gameState !== 'PLAYING') return;

        ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        frameCount++;

        // 1. èƒŒæ™¯é›² (è¦–å·®æ•ˆæœ)
        clouds.forEach(c => { c.update(); c.draw(); });

        // 2. æ›´æ–°å¯¦é«”
        player.update();
        player.draw();

        spawnEnemy();

        enemies.forEach(e => { e.update(); e.draw(); });
        bullets.forEach(b => { b.update(); b.draw(); });
        powerups.forEach(p => { p.update(); p.draw(); });
        particles.forEach(p => { p.update(); p.draw(); });

        // 3. æ¸…ç†ç„¡æ•ˆç‰©ä»¶ (Object Pooling æ¨¡æ“¬)
        bullets = bullets.filter(b => b.active);
        enemies = enemies.filter(e => e.active);
        powerups = powerups.filter(p => p.active);
        particles = particles.filter(p => p.life > 0);

        // 4. ç¢°æ’
        checkCollisions();

        // 5. UI æ›´æ–° (åˆ†æ•¸)
        if (frameCount % 10 === 0) document.getElementById('score').innerText = score;

        requestAnimationFrame(loop);
    }

    // --- è¼¸å…¥ç›£è½ ---
    function handleInput(e) {
        if (gameState !== 'PLAYING') return;
        // e.preventDefault(); // é˜²æ­¢æ»¾å‹• (å¦‚æœæœ‰éœ€è¦)
        
        const rect = canvas.getBoundingClientRect();
        const scaleX = GAME_WIDTH / rect.width;
        const scaleY = GAME_HEIGHT / rect.height;

        let clientX, clientY;
        if (e.touches) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }

        input.x = (clientX - rect.left) * scaleX;
        input.y = (clientY - rect.top) * scaleY;
        input.active = true;
    }

    function stopInput() {
        input.active = false;
    }

    const stage = document.getElementById('game-stage');
    stage.addEventListener('mousemove', handleInput);
    stage.addEventListener('touchmove', handleInput, {passive: false});
    stage.addEventListener('touchstart', handleInput, {passive: false});
    stage.addEventListener('touchend', stopInput);

</script>
</body>
</html>