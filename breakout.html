<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>çˆ†ç ´æ‰“ç£šå¡Š ğŸ§±</title>
    <style>
        body { 
            background: #0f0c29; 
            color: white; 
            margin: 0; 
            overflow: hidden; 
            touch-action: none; 
            font-family: "Microsoft JhengHei", sans-serif;
            text-align: center;
        }
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        #header {
            padding: 15px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .score-box { font-size: 24px; font-weight: bold; color: #f1c40f; text-shadow: 0 0 10px #f1c40f; }
        .ball-count { font-size: 16px; color: #00d2ff; }
        
        #gameCanvas { 
            display: block; 
            background: radial-gradient(circle at center, #1a1a2e, #000); 
        }

        /* éŠæˆ²çµæŸ/æš«åœä»‹é¢ */
        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 10;
        }
        h1 { margin: 0 0 20px 0; font-size: 40px; color: #ff0055; text-shadow: 0 0 20px red; }
        p { color: #ccc; margin-bottom: 30px; font-size: 18px; }
        button {
            padding: 15px 40px;
            font-size: 24px;
            background: #00d2ff;
            color: #000;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 0 20px #00d2ff;
            font-weight: bold;
        }
        button:active { transform: scale(0.95); }
        .home-btn {
            position: absolute;
            top: 15px; left: 15px;
            pointer-events: auto;
            background: rgba(255,255,255,0.2);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            text-decoration: none;
            font-size: 14px;
            border: 1px solid rgba(255,255,255,0.3);
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="header">
            <a href="index.html" class="home-btn">ğŸ  å›å¤§å»³</a>
            <div style="flex-grow:1"></div>
            <div class="score-box">åˆ†æ•¸: <span id="scoreVal">0</span></div>
        </div>
        <div style="padding:10px; opacity:0.5; font-size:12px;">å·¦å³æ»‘å‹•æ§åˆ¶æ“‹æ¿</div>
    </div>

    <div id="overlay">
        <h1 id="msg-title">çˆ†ç ´æ‰“ç£šå¡Š</h1>
        <p id="msg-desc">é»æ“ŠæŒ‰éˆ•é–‹å§‹éŠæˆ²</p>
        <button onclick="startGame()">ğŸš€ ç™¼å°„çƒ</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let canvasW, canvasH;
        let animationId;
        let isPlaying = false;
        let score = 0;
        let lastScoreCheckpoint = 0; // ç”¨ä¾†è¨ˆç®—ä½•æ™‚åŠ çƒ

        // éŠæˆ²åƒæ•¸
        const PADDLE_HEIGHT = 20;
        let PADDLE_WIDTH = 100;
        let paddleX;
        
        const BALL_RADIUS = 8;
        const MAX_BALLS = 5;
        let balls = []; // å­˜æ”¾æ‰€æœ‰çƒçš„é™£åˆ—

        // ç£šå¡Šåƒæ•¸
        const BRICK_ROW_COUNT = 6;
        const BRICK_COL_COUNT = 5; // æ‰‹æ©Ÿä¸Šåˆ—æ•¸å°‘ä¸€é»æ¯”è¼ƒå¥½æ‰“
        let brickWidth, brickHeight;
        const brickPadding = 10;
        const brickOffsetTop = 80;
        const brickOffsetLeft = 20; // å·¦å³é‚Šè·
        let bricks = [];
        let particles = []; // çˆ†ç‚¸ç‰¹æ•ˆç²’å­

        // åˆå§‹åŒ–ç•«å¸ƒå°ºå¯¸
        function resize() {
            canvasW = window.innerWidth;
            canvasH = window.innerHeight;
            canvas.width = canvasW;
            canvas.height = canvasH;
            
            // éŸ¿æ‡‰å¼è¨ˆç®—
            PADDLE_WIDTH = Math.min(120, canvasW * 0.25);
            paddleX = (canvasW - PADDLE_WIDTH) / 2;
            
            // è¨ˆç®—ç£šå¡Šå¯¬åº¦
            const totalPadding = (BRICK_COL_COUNT - 1) * brickPadding + (brickOffsetLeft * 2);
            brickWidth = (canvasW - totalPadding) / BRICK_COL_COUNT;
            brickHeight = 25;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- éŠæˆ²é‚è¼¯ ---

        function initBricks() {
            bricks = [];
            for(let c=0; c<BRICK_COL_COUNT; c++) {
                bricks[c] = [];
                for(let r=0; r<BRICK_ROW_COUNT; r++) {
                    // 20% æ©Ÿç‡ç”Ÿæˆçˆ†ç‚¸ç£šå¡Š
                    let isExplosive = Math.random() < 0.2;
                    bricks[c][r] = { 
                        x: 0, y: 0, status: 1, 
                        type: isExplosive ? 'BOMB' : 'NORMAL',
                        color: isExplosive ? '#ff0055' : `hsl(${r * 40}, 70%, 50%)`
                    };
                }
            }
        }

        function createBall(x, y, speedMult = 1) {
            let angle = Math.random() * Math.PI / 2 + Math.PI / 4; // éš¨æ©Ÿå‘ä¸Šè§’åº¦
            let speed = 6 * speedMult;
            balls.push({
                x: x,
                y: y,
                dx: Math.cos(angle) * speed * (Math.random() < 0.5 ? 1 : -1),
                dy: -Math.sin(angle) * speed,
                active: true
            });
        }

        function spawnParticles(x, y, color) {
            for(let i=0; i<15; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 1.0,
                    color: color
                });
            }
        }

        function drawPaddle() {
            ctx.beginPath();
            ctx.roundRect(paddleX, canvasH - PADDLE_HEIGHT - 30, PADDLE_WIDTH, PADDLE_HEIGHT, 10);
            ctx.fillStyle = "#00d2ff";
            ctx.shadowBlur = 15;
            ctx.shadowColor = "#00d2ff";
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.closePath();
        }

        function drawBalls() {
            balls.forEach(ball => {
                if(!ball.active) return;
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, Math.PI*2);
                ctx.fillStyle = "#ffffff";
                ctx.shadowBlur = 10;
                ctx.shadowColor = "#ffffff";
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.closePath();
            });
        }

        function drawBricks() {
            for(let c=0; c<BRICK_COL_COUNT; c++) {
                for(let r=0; r<BRICK_ROW_COUNT; r++) {
                    let b = bricks[c][r];
                    if(b.status === 1) {
                        let brickX = (c * (brickWidth + brickPadding)) + brickOffsetLeft;
                        let brickY = (r * (brickHeight + brickPadding)) + brickOffsetTop;
                        b.x = brickX;
                        b.y = brickY;
                        
                        ctx.beginPath();
                        ctx.roundRect(brickX, brickY, brickWidth, brickHeight, 5);
                        
                        // çˆ†ç‚¸ç£šå¡Šé–ƒçˆæ•ˆæœ
                        if (b.type === 'BOMB') {
                            ctx.fillStyle = (Date.now() % 500 < 250) ? '#ff0000' : '#800000';
                            ctx.shadowBlur = 15;
                            ctx.shadowColor = 'red';
                        } else {
                            ctx.fillStyle = b.color;
                            ctx.shadowBlur = 0;
                        }
                        
                        ctx.fill();
                        ctx.closePath();
                        
                        // ç•«ç‚¸å½ˆæ¨™èªŒ
                        if (b.type === 'BOMB') {
                            ctx.fillStyle = 'white';
                            ctx.font = '16px Arial';
                            ctx.fillText('ğŸ’£', brickX + brickWidth/2 - 8, brickY + 18);
                        }
                    }
                }
            }
        }

        function drawParticles() {
            for(let i=particles.length-1; i>=0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.05;
                
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1.0;

                if(p.life <= 0) particles.splice(i, 1);
            }
        }

        // çˆ†ç‚¸é‚è¼¯ï¼šç‚¸æ‰å‘¨åœ 3x3 å€åŸŸ
        function triggerExplosion(col, row) {
            spawnParticles(bricks[col][row].x + brickWidth/2, bricks[col][row].y + brickHeight/2, '#ffaa00');
            
            // éœ‡å‹•ç•«é¢
            // (ç°¡å–®å¯¦ä½œï¼šå¯é¸)
            
            for(let c = col-1; c <= col+1; c++) {
                for(let r = row-1; r <= row+1; r++) {
                    if(c >= 0 && c < BRICK_COL_COUNT && r >= 0 && r < BRICK_ROW_COUNT) {
                        let b = bricks[c][r];
                        if(b.status === 1) {
                            b.status = 0;
                            score += 20; // çˆ†ç‚¸é€£é–åŠ åˆ†
                            spawnParticles(b.x + brickWidth/2, b.y + brickHeight/2, b.color);
                        }
                    }
                }
            }
        }

        function collisionDetection() {
            balls.forEach(ball => {
                if(!ball.active) return;
                
                for(let c=0; c<BRICK_COL_COUNT; c++) {
                    for(let r=0; r<BRICK_ROW_COUNT; r++) {
                        let b = bricks[c][r];
                        if(b.status === 1) {
                            if(ball.x > b.x && ball.x < b.x+brickWidth && ball.y > b.y && ball.y < b.y+brickHeight) {
                                ball.dy = -ball.dy;
                                
                                // ä¸€èˆ¬æ¶ˆé™¤
                                if(b.type === 'BOMB') {
                                    triggerExplosion(c, r);
                                } else {
                                    b.status = 0;
                                    score += 10;
                                    spawnParticles(b.x + brickWidth/2, b.y + brickHeight/2, b.color);
                                }
                                
                                // æª¢æŸ¥æ˜¯å¦åŠ çƒ (æ¯500åˆ†åŠ ä¸€é¡†ï¼Œæœ€å¤š5é¡†)
                                if (score - lastScoreCheckpoint >= 500) {
                                    if(balls.length < MAX_BALLS) {
                                        createBall(paddleX + PADDLE_WIDTH/2, canvasH - 60);
                                        // æç¤ºæ–‡å­— (å¯é¸)
                                    }
                                    lastScoreCheckpoint += 500;
                                }

                                checkWin();
                            }
                        }
                    }
                }
            });
        }

        function checkWin() {
            // æª¢æŸ¥æ˜¯å¦æ‰€æœ‰ç£šå¡Šéƒ½æ¶ˆé™¤äº†
            let isWin = true;
            for(let c=0; c<BRICK_COL_COUNT; c++) {
                for(let r=0; r<BRICK_ROW_COUNT; r++) {
                    if(bricks[c][r].status === 1) isWin = false;
                }
            }
            if(isWin) {
                gameOver("æ­å–œéé—œï¼", "æ‰€æœ‰ç£šå¡Šå·²æ¸…é™¤");
            }
        }

        function update() {
            if(!isPlaying) return;

            // æ›´æ–°æ“‹æ¿ä½ç½® (ç”±æ»‘é¼ /è§¸æ§äº‹ä»¶æ§åˆ¶)
            
            // æ›´æ–°çƒ
            let activeBalls = 0;
            balls.forEach(ball => {
                if(!ball.active) return;
                activeBalls++;

                ball.x += ball.dx;
                ball.y += ball.dy;

                // æ’ç‰† (å·¦å³)
                if(ball.x + ball.dx > canvasW - BALL_RADIUS || ball.x + ball.dx < BALL_RADIUS) {
                    ball.dx = -ball.dx;
                }
                // æ’é ‚éƒ¨
                if(ball.y + ball.dy < BALL_RADIUS) {
                    ball.dy = -ball.dy;
                }
                // æ’åº•éƒ¨ (æ­»æ‰)
                else if(ball.y + ball.dy > canvasH - BALL_RADIUS) {
                    // æª¢æŸ¥æ˜¯å¦æ’åˆ°æ“‹æ¿
                    if(ball.x > paddleX && ball.x < paddleX + PADDLE_WIDTH && ball.y > canvasH - PADDLE_HEIGHT - 40) {
                        // æ ¹æ“šæ’æ“Šé»æ”¹è®Šåå½ˆè§’åº¦ (å¢åŠ æ“æ§æ€§)
                        let hitPoint = ball.x - (paddleX + PADDLE_WIDTH/2);
                        hitPoint = hitPoint / (PADDLE_WIDTH/2); // -1 åˆ° 1
                        
                        let speed = Math.sqrt(ball.dx*ball.dx + ball.dy*ball.dy);
                        let angle = hitPoint * (Math.PI/3); // æœ€å¤§åè½‰ 60åº¦
                        
                        ball.dx = speed * Math.sin(angle);
                        ball.dy = -speed * Math.cos(angle);
                    } else {
                        // çœŸçš„æ‰ä¸‹å»äº†
                        ball.active = false;
                    }
                }
            });

            if(activeBalls === 0) {
                gameOver("éŠæˆ²çµæŸ", "å¾—åˆ†: " + score);
            }

            collisionDetection();
        }

        function draw() {
            ctx.clearRect(0, 0, canvasW, canvasH);
            drawBricks();
            drawPaddle();
            drawBalls();
            drawParticles();
            
            document.getElementById('scoreVal').innerText = score;
        }

        function gameLoop() {
            if(isPlaying) {
                update();
                draw();
                animationId = requestAnimationFrame(gameLoop);
            }
        }

        function startGame() {
            document.getElementById('overlay').style.display = 'none';
            score = 0;
            lastScoreCheckpoint = 0;
            balls = [];
            initBricks();
            // åˆå§‹ç™¼ä¸€é¡†çƒ
            createBall(canvasW/2, canvasH - 100);
            
            isPlaying = true;
            gameLoop();
        }

        function gameOver(title, desc) {
            isPlaying = false;
            cancelAnimationFrame(animationId);
            document.getElementById('msg-title').innerText = title;
            document.getElementById('msg-desc').innerText = desc;
            document.getElementById('overlay').style.display = 'flex';
        }

        // --- æ“æ§äº‹ä»¶ ---
        function movePaddle(e) {
            let relativeX;
            if(e.type === 'touchmove') {
                relativeX = e.touches[0].clientX;
            } else {
                relativeX = e.clientX;
            }

            if(relativeX > 0 && relativeX < canvasW) {
                paddleX = relativeX - PADDLE_WIDTH / 2;
                
                // é‚Šç•Œæª¢æŸ¥
                if (paddleX < 0) paddleX = 0;
                if (paddleX + PADDLE_WIDTH > canvasW) paddleX = canvasW - PADDLE_WIDTH;
            }
        }

        document.addEventListener('mousemove', movePaddle, false);
        document.addEventListener('touchmove', (e) => {
            e.preventDefault(); // é˜²æ­¢æ»¾å‹•
            movePaddle(e);
        }, { passive: false });

    </script>
</body>
</html>