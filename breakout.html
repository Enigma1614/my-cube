<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>çˆ†ç ´æ‰“ç£šå¡Š ğŸ§±</title>
    <style>
        body { 
            background: #0f0c29; color: white; margin: 0; overflow: hidden; 
            touch-action: none; font-family: "Microsoft JhengHei", sans-serif; text-align: center;
        }
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column;
        }
        #header {
            padding: 15px; background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            display: flex; justify-content: space-between; align-items: center;
        }
        .score-box { font-size: 24px; font-weight: bold; color: #f1c40f; text-shadow: 0 0 10px #f1c40f; }
        #powerup-status {
            position: absolute; bottom: 60px; width: 100%; text-align: center;
            font-size: 18px; color: #00ff00; text-shadow: 0 0 10px #00ff00;
            opacity: 0; transition: opacity 0.3s; pointer-events: none;
        }
        #gameCanvas { display: block; background: radial-gradient(circle at center, #1a1a2e, #000); }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: flex; flex-direction: column;
            justify-content: center; align-items: center; pointer-events: auto; z-index: 10;
        }
        h1 { margin: 0 0 20px 0; font-size: 40px; color: #ff0055; text-shadow: 0 0 20px red; }
        p { color: #ccc; margin-bottom: 30px; font-size: 18px; }
        button {
            padding: 15px 40px; font-size: 24px; background: #00d2ff; color: #000;
            border: none; border-radius: 50px; cursor: pointer; box-shadow: 0 0 20px #00d2ff; font-weight: bold;
        }
        button:active { transform: scale(0.95); }
        .home-btn {
            position: absolute; top: 15px; left: 15px; pointer-events: auto;
            background: rgba(255,255,255,0.2); color: white; padding: 8px 15px;
            border-radius: 20px; text-decoration: none; font-size: 14px; border: 1px solid rgba(255,255,255,0.3);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui-layer">
        <div id="header">
            <a href="index.html" class="home-btn">ğŸ  å›å¤§å»³</a>
            <div style="flex-grow:1"></div>
            <div class="score-box">åˆ†æ•¸: <span id="scoreVal">0</span></div>
        </div>
        <div id="powerup-status"></div>
    </div>
    <div id="overlay">
        <h1 id="msg-title">çˆ†ç ´æ‰“ç£šå¡Š</h1>
        <p id="msg-desc">é»æ“ŠæŒ‰éˆ•é–‹å§‹éŠæˆ²</p>
        <button onclick="startGame()">ğŸš€ ç™¼å°„çƒ</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const powerupStatus = document.getElementById('powerup-status');
        
        let canvasW, canvasH, animationId, isPlaying = false;
        let score = 0, lastScoreCheckpoint = 0;

        // æ“‹æ¿åƒæ•¸
        const PADDLE_HEIGHT = 20;
        let BASE_PADDLE_WIDTH = 100;
        let currentPaddleWidth;
        let paddleX;
        let powerupTimer = null;
        
        // çƒåƒæ•¸
        const BALL_RADIUS = 8, MAX_BALLS = 5;
        let balls = [];

        // ç£šå¡Šåƒæ•¸
        const BRICK_ROW_COUNT = 6, BRICK_COL_COUNT = 5;
        let brickWidth, brickHeight;
        const brickPadding = 10, brickOffsetTop = 80, brickOffsetLeft = 20;
        let bricks = [], particles = [];

        function resize() {
            canvasW = window.innerWidth; canvasH = window.innerHeight;
            canvas.width = canvasW; canvas.height = canvasH;
            BASE_PADDLE_WIDTH = Math.min(120, canvasW * 0.25);
            // å¦‚æœæ²’æœ‰é“å…·ç‹€æ…‹ï¼Œé‡ç½®æ“‹æ¿å¯¬åº¦
            if (!powerupTimer) currentPaddleWidth = BASE_PADDLE_WIDTH;
            paddleX = (canvasW - currentPaddleWidth) / 2;
            const totalPadding = (BRICK_COL_COUNT - 1) * brickPadding + (brickOffsetLeft * 2);
            brickWidth = (canvasW - totalPadding) / BRICK_COL_COUNT;
            brickHeight = 25;
        }
        window.addEventListener('resize', resize); resize();

        function initBricks() {
            bricks = [];
            for(let c=0; c<BRICK_COL_COUNT; c++) {
                bricks[c] = [];
                for(let r=0; r<BRICK_ROW_COUNT; r++) {
                    let rand = Math.random();
                    let type = 'NORMAL';
                    let color = `hsl(${r * 40}, 70%, 50%)`;
                    
                    if (rand < 0.05) { // 5% æ©Ÿç‡çˆ†ç‚¸ç£š
                        type = 'BOMB'; color = '#ff0055';
                    } else if (rand < 0.15) { // 10% æ©Ÿç‡è®Šé•·é“å…·
                        type = 'LONG'; color = '#00ff00';
                    }

                    bricks[c][r] = { x: 0, y: 0, status: 1, type: type, color: color };
                }
            }
        }

        function createBall(x, y) {
            let angle = Math.random() * Math.PI / 2 + Math.PI / 4;
            let speed = 6;
            balls.push({
                x: x, y: y,
                dx: Math.cos(angle) * speed * (Math.random() < 0.5 ? 1 : -1),
                dy: -Math.sin(angle) * speed,
                active: true
            });
        }

        function spawnParticles(x, y, color) {
            for(let i=0; i<15; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 10, vy: (Math.random() - 0.5) * 10,
                    life: 1.0, color: color
                });
            }
        }

        // é“å…·æ•ˆæœï¼šæ“‹æ¿è®Šé•·
        function activatePowerup() {
            if (powerupTimer) clearTimeout(powerupTimer);
            currentPaddleWidth = BASE_PADDLE_WIDTH * 1.5; // è®Šé•· 50%
            
            powerupStatus.innerText = "æ“‹æ¿è®Šé•·ï¼ (10ç§’)";
            powerupStatus.style.opacity = 1;

            powerupTimer = setTimeout(() => {
                currentPaddleWidth = BASE_PADDLE_WIDTH;
                powerupStatus.style.opacity = 0;
                powerupTimer = null;
            }, 10000);
        }

        function drawPaddle() {
            ctx.beginPath();
            ctx.roundRect(paddleX, canvasH - PADDLE_HEIGHT - 30, currentPaddleWidth, PADDLE_HEIGHT, 10);
            ctx.fillStyle = powerupTimer ? "#00ff00" : "#00d2ff"; // æœ‰é“å…·æ™‚è®Šç¶ è‰²
            ctx.shadowBlur = 15; ctx.shadowColor = ctx.fillStyle;
            ctx.fill(); ctx.shadowBlur = 0; ctx.closePath();
        }

        function drawBalls() {
            balls.forEach(ball => {
                if(!ball.active) return;
                ctx.beginPath(); ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, Math.PI*2);
                ctx.fillStyle = "#ffffff"; ctx.shadowBlur = 10; ctx.shadowColor = "#ffffff";
                ctx.fill(); ctx.shadowBlur = 0; ctx.closePath();
            });
        }

        function drawBricks() {
            for(let c=0; c<BRICK_COL_COUNT; c++) for(let r=0; r<BRICK_ROW_COUNT; r++) {
                let b = bricks[c][r];
                if(b.status === 1) {
                    let brickX = (c * (brickWidth + brickPadding)) + brickOffsetLeft;
                    let brickY = (r * (brickHeight + brickPadding)) + brickOffsetTop;
                    b.x = brickX; b.y = brickY;
                    ctx.beginPath(); ctx.roundRect(brickX, brickY, brickWidth, brickHeight, 5);
                    
                    if (b.type === 'BOMB' || b.type === 'LONG') {
                        ctx.fillStyle = (Date.now() % 500 < 250) ? b.color : '#ffffff';
                        ctx.shadowBlur = 15; ctx.shadowColor = b.color;
                    } else {
                        ctx.fillStyle = b.color; ctx.shadowBlur = 0;
                    }
                    ctx.fill(); ctx.closePath();

                    if (b.type === 'BOMB') { ctx.fillStyle='white'; ctx.font='16px Arial'; ctx.fillText('ğŸ’£', brickX+brickWidth/2-8, brickY+18); }
                    if (b.type === 'LONG') { ctx.fillStyle='black'; ctx.font='16px Arial'; ctx.fillText('â­', brickX+brickWidth/2-8, brickY+18); }
                }
            }
        }

        function drawParticles() {
            for(let i=particles.length-1; i>=0; i--) {
                let p = particles[i]; p.x+=p.vx; p.y+=p.vy; p.life-=0.05;
                ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill();
                ctx.globalAlpha = 1.0;
                if(p.life <= 0) particles.splice(i, 1);
            }
        }

        function triggerExplosion(col, row) {
            spawnParticles(bricks[col][row].x + brickWidth/2, bricks[col][row].y + brickHeight/2, '#ffaa00');
            for(let c=col-1; c<=col+1; c++) for(let r=row-1; r<=row+1; r++) {
                if(c>=0 && c<BRICK_COL_COUNT && r>=0 && r<BRICK_ROW_COUNT) {
                    let b = bricks[c][r];
                    if(b.status === 1) {
                        b.status = 0; score += 20;
                        spawnParticles(b.x + brickWidth/2, b.y + brickHeight/2, b.color);
                        if(b.type === 'LONG') activatePowerup(); // ç‚¸åˆ°é“å…·ä¹Ÿè¦è§¸ç™¼
                    }
                }
            }
        }

        function collisionDetection() {
            balls.forEach(ball => {
                if(!ball.active) return;
                for(let c=0; c<BRICK_COL_COUNT; c++) for(let r=0; r<BRICK_ROW_COUNT; r++) {
                    let b = bricks[c][r];
                    if(b.status === 1) {
                        if(ball.x > b.x && ball.x < b.x+brickWidth && ball.y > b.y && ball.y < b.y+brickHeight) {
                            ball.dy = -ball.dy;
                            if(b.type === 'BOMB') triggerExplosion(c, r);
                            else {
                                b.status = 0; score += 10;
                                spawnParticles(b.x+brickWidth/2, b.y+brickHeight/2, b.color);
                                if(b.type === 'LONG') activatePowerup();
                            }
                            if (score - lastScoreCheckpoint >= 500) {
                                if(balls.length < MAX_BALLS) createBall(paddleX + currentPaddleWidth/2, canvasH - 60);
                                lastScoreCheckpoint += 500;
                            }
                            checkWin();
                        }
                    }
                }
            });
        }

        function checkWin() {
            let isWin = true;
            for(let c=0; c<BRICK_COL_COUNT; c++) for(let r=0; r<BRICK_ROW_COUNT; r++) if(bricks[c][r].status === 1) isWin = false;
            if(isWin) gameOver("æ­å–œéé—œï¼", "æ‰€æœ‰ç£šå¡Šå·²æ¸…é™¤");
        }

        function update() {
            if(!isPlaying) return;
            let activeBalls = 0;
            const paddleTopY = canvasH - PADDLE_HEIGHT - 30;

            balls.forEach(ball => {
                if(!ball.active) return;
                activeBalls++;
                ball.x += ball.dx; ball.y += ball.dy;

                if(ball.x + ball.dx > canvasW - BALL_RADIUS || ball.x + ball.dx < BALL_RADIUS) ball.dx = -ball.dx;
                if(ball.y + ball.dy < BALL_RADIUS) ball.dy = -ball.dy;
                
                // --- ä¿®æ­£æ“‹æ¿ç¢°æ’é‚è¼¯ ---
                // æª¢æŸ¥çƒæ˜¯å¦åˆ°é”æ“‹æ¿é«˜åº¦
                if(ball.y + BALL_RADIUS >= paddleTopY && ball.dy > 0) {
                    // æª¢æŸ¥çƒçš„ X åº§æ¨™æ˜¯å¦åœ¨æ“‹æ¿ç¯„åœå…§
                    if(ball.x >= paddleX && ball.x <= paddleX + currentPaddleWidth) {
                        ball.y = paddleTopY - BALL_RADIUS; // å¼·åˆ¶ä¿®æ­£ä½ç½®åˆ°æ“‹æ¿ä¸Šæ–¹
                        ball.dy = -ball.dy; // åå½ˆ

                        // æ ¹æ“šæ’æ“Šé»æ”¹è®Šè§’åº¦
                        let hitPoint = ball.x - (paddleX + currentPaddleWidth/2);
                        hitPoint = hitPoint / (currentPaddleWidth/2);
                        let speed = Math.sqrt(ball.dx*ball.dx + ball.dy*ball.dy);
                        let angle = hitPoint * (Math.PI/3);
                        ball.dx = speed * Math.sin(angle);
                        ball.dy = -speed * Math.cos(angle);
                    } else if (ball.y - BALL_RADIUS > canvasH) {
                        // çœŸçš„æ‰å‡ºè¢å¹•å¤–æ‰ç®—æ­»æ‰
                        ball.active = false;
                    }
                }
            });

            if(activeBalls === 0) gameOver("éŠæˆ²çµæŸ", "å¾—åˆ†: " + score);
            collisionDetection();
        }

        function draw() {
            ctx.clearRect(0, 0, canvasW, canvasH);
            drawBricks(); drawPaddle(); drawBalls(); drawParticles();
            document.getElementById('scoreVal').innerText = score;
        }

        function gameLoop() { if(isPlaying) { update(); draw(); animationId = requestAnimationFrame(gameLoop); } }

        function startGame() {
            document.getElementById('overlay').style.display = 'none';
            score = 0; lastScoreCheckpoint = 0; balls = [];
            initBricks();
            if (powerupTimer) { clearTimeout(powerupTimer); powerupTimer = null; }
            currentPaddleWidth = BASE_PADDLE_WIDTH;
            powerupStatus.style.opacity = 0;
            resize();
            createBall(canvasW/2, canvasH - 100);
            isPlaying = true; gameLoop();
        }

        function gameOver(title, desc) {
            isPlaying = false; cancelAnimationFrame(animationId);
            document.getElementById('msg-title').innerText = title;
            document.getElementById('msg-desc').innerText = desc;
            document.getElementById('overlay').style.display = 'flex';
        }

        function movePaddle(e) {
            let relativeX = (e.type === 'touchmove') ? e.touches[0].clientX : e.clientX;
            if(relativeX > 0 && relativeX < canvasW) {
                paddleX = relativeX - currentPaddleWidth / 2;
                if (paddleX < 0) paddleX = 0;
                if (paddleX + currentPaddleWidth > canvasW) paddleX = canvasW - currentPaddleWidth;
            }
        }
        document.addEventListener('mousemove', movePaddle, false);
        document.addEventListener('touchmove', (e) => { e.preventDefault(); movePaddle(e); }, { passive: false });
    </script>
</body>
</html>
