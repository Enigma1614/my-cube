<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>貪食蛇 Snake</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#101a30;
      --text:#e6eefc;
      --muted:#9fb2d6;
      --accent:#4cc9f0;
      --snake:#7CFF6B;
      --snake2:#44d86f;
      --food:#ff4d6d;
      --grid:#172447;
      --shadow: 0 12px 28px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box;}
    body{
      margin:0;
      min-height:100vh;
      display:grid;
      place-items:center;
      background: radial-gradient(1200px 600px at 20% 20%, #152853 0%, var(--bg) 55%, #070b14 100%);
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", "PingFang TC", "Microsoft JhengHei", sans-serif;
      color:var(--text);
    }
    .wrap{
      width:min(900px, 92vw);
      display:grid;
      gap:14px;
      grid-template-columns: 1fr;
      align-items:start;
    }
    header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
      padding:14px 16px;
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(6px);
    }
    header h1{
      margin:0;
      font-size:18px;
      letter-spacing:.5px;
      display:flex;
      align-items:center;
      gap:10px;
    }
    .badge{
      font-size:12px;
      color:#07111f;
      background:linear-gradient(90deg, var(--accent), #b8f2ff);
      padding:4px 8px;
      border-radius:999px;
      font-weight:700;
    }
    .stats{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
      align-items:center;
      font-size:13px;
      color:var(--muted);
    }
    .stats b{ color:var(--text); font-weight:800; }
    .panel{
      display:grid;
      grid-template-columns: 1fr 280px;
      gap:14px;
    }
    @media (max-width: 760px){
      .panel{ grid-template-columns: 1fr; }
    }
    .game{
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      box-shadow: var(--shadow);
      padding:14px;
    }
    canvas{
      width:100%;
      height:auto;
      display:block;
      border-radius:12px;
      background:
        linear-gradient(var(--grid) 1px, transparent 1px),
        linear-gradient(90deg, var(--grid) 1px, transparent 1px),
        radial-gradient(900px 500px at 50% 0%, rgba(76,201,240,.18), transparent 55%),
        #061022;
      background-size: 24px 24px, 24px 24px, auto, auto;
      border:1px solid rgba(255,255,255,.08);
    }
    .side{
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      box-shadow: var(--shadow);
      padding:14px;
      display:grid;
      gap:12px;
    }
    .row{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
    }
    .row label{
      font-size:13px;
      color:var(--muted);
    }
    input[type="range"]{
      width: 150px;
      accent-color: var(--accent);
    }
    .btns{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    button{
      cursor:pointer;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      font-weight:700;
      letter-spacing:.2px;
      transition: transform .06s ease, background .2s ease;
      user-select:none;
    }
    button:hover{ background: rgba(255,255,255,.10); }
    button:active{ transform: translateY(1px); }
    .primary{
      background: linear-gradient(90deg, rgba(76,201,240,.25), rgba(124,255,107,.18));
      border-color: rgba(76,201,240,.35);
    }
    .hint{
      font-size:12px;
      color:var(--muted);
      line-height:1.6;
      padding:10px 12px;
      border-radius:12px;
      background: rgba(0,0,0,.16);
      border:1px dashed rgba(255,255,255,.12);
    }
    .toast{
      margin-top:10px;
      font-size:12px;
      color:var(--muted);
      text-align:center;
      opacity:.9;
    }
    .overlay{
      position:absolute;
      inset:0;
      display:grid;
      place-items:center;
      pointer-events:none;
    }
    .msg{
      pointer-events:none;
      text-align:center;
      padding:12px 16px;
      border-radius:14px;
      background: rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(6px);
      box-shadow: var(--shadow);
    }
    .msg h2{ margin:0 0 6px; font-size:18px;}
    .msg p{ margin:0; color:var(--muted); font-size:13px; }
    .rel{ position:relative; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>貪食蛇 <span class="badge">Snake</span></h1>
      <div class="stats">
        分數：<b id="score">0</b>
        最高分：<b id="best">0</b>
        狀態：<b id="state">暫停</b>
      </div>
    </header>

    <div class="panel">
      <section class="game rel">
        <canvas id="c" width="600" height="600" aria-label="snake-canvas"></canvas>
        <div class="overlay" id="overlay">
          <div class="msg" id="msg">
            <h2>按下 空白鍵 開始</h2>
            <p>方向鍵 / WASD 控制，R 重新開始</p>
          </div>
        </div>
        <div class="toast">Tip：手機可滑動改方向；也可點右側「開始/暫停」</div>
      </section>

      <aside class="side">
        <div class="row">
          <label>速度</label>
          <div>
            <input id="speed" type="range" min="6" max="18" step="1" value="10">
            <span id="speedVal">10</span>
          </div>
        </div>

        <div class="row">
          <label>格子大小</label>
          <div>
            <input id="cell" type="range" min="12" max="30" step="2" value="24">
            <span id="cellVal">24</span>
          </div>
        </div>

        <div class="btns">
          <button class="primary" id="toggle">開始</button>
          <button id="restart">重新開始</button>
        </div>

        <div class="hint">
          <b>操作：</b><br/>
          • 空白鍵：開始/暫停<br/>
          • 方向鍵 或 WASD：移動<br/>
          • R：重新開始<br/>
          <br/>
          <b>規則：</b><br/>
          吃到紅色食物加分變長，撞牆或咬到自己就結束。
        </div>
      </aside>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const elScore = document.getElementById('score');
  const elBest  = document.getElementById('best');
  const elState = document.getElementById('state');
  const overlay = document.getElementById('overlay');
  const msgBox  = document.getElementById('msg');

  const speedSlider = document.getElementById('speed');
  const cellSlider  = document.getElementById('cell');
  const speedVal    = document.getElementById('speedVal');
  const cellVal     = document.getElementById('cellVal');

  const btnToggle  = document.getElementById('toggle');
  const btnRestart = document.getElementById('restart');

  const LS_KEY = 'snake_best_score_v1';
  let best = Number(localStorage.getItem(LS_KEY) || 0);
  elBest.textContent = best;

  // game state
  let cell = Number(cellSlider.value);        // px per grid cell
  let cols = Math.floor(canvas.width / cell);
  let rows = Math.floor(canvas.height / cell);

  let speed = Number(speedSlider.value);      // ticks per second
  let lastTime = 0;
  let acc = 0;

  let running = false;
  let gameOver = false;

  let dir = {x:1, y:0};
  let nextDir = {x:1, y:0};

  let snake = [];
  let food = {x: 10, y: 10};
  let score = 0;

  function reset(){
    score = 0;
    elScore.textContent = score;

    dir = {x:1, y:0};
    nextDir = {x:1, y:0};
    const sx = Math.floor(cols/2);
    const sy = Math.floor(rows/2);

    snake = [
      {x:sx-2, y:sy},
      {x:sx-1, y:sy},
      {x:sx,   y:sy},
    ];

    placeFood();
    gameOver = false;
    updateStateText();
    showOverlay('按下 空白鍵 開始', '方向鍵 / WASD 控制，R 重新開始');
    draw();
  }

  function updateGrid(){
    cell = Number(cellSlider.value);
    cols = Math.floor(canvas.width / cell);
    rows = Math.floor(canvas.height / cell);
    cellVal.textContent = cell;
  }

  function placeFood(){
    // place food on an empty cell
    const occupied = new Set(snake.map(p => `${p.x},${p.y}`));
    let x,y, tries = 0;
    do{
      x = Math.floor(Math.random()*cols);
      y = Math.floor(Math.random()*rows);
      tries++;
      if(tries > 200) break; // fallback
    } while(occupied.has(`${x},${y}`));
    food = {x,y};
  }

  function updateStateText(){
    elState.textContent = gameOver ? '結束' : (running ? '進行中' : '暫停');
    btnToggle.textContent = running ? '暫停' : '開始';
  }

  function showOverlay(title, subtitle){
    overlay.style.display = 'grid';
    msgBox.innerHTML = `<h2>${title}</h2><p>${subtitle}</p>`;
  }
  function hideOverlay(){
    overlay.style.display = 'none';
  }

  function toggle(){
    if(gameOver){
      reset();
    }
    running = !running;
    updateStateText();
    if(running) hideOverlay();
    else showOverlay('已暫停', '按下 空白鍵 或「開始」繼續');
  }

  function step(){
    // apply buffered direction change, prevent reversing
    if((nextDir.x !== -dir.x) || (nextDir.y !== -dir.y)){
      dir = {...nextDir};
    }

    const head = snake[snake.length - 1];
    const nx = head.x + dir.x;
    const ny = head.y + dir.y;

    // collision with wall
    if(nx < 0 || nx >= cols || ny < 0 || ny >= rows){
      endGame();
      return;
    }

    // collision with self (allow moving into tail only if tail will move away)
    const tail = snake[0];
    const willEat = (nx === food.x && ny === food.y);
    const bodySet = new Set(snake.map(p => `${p.x},${p.y}`));
    if(bodySet.has(`${nx},${ny}`)){
      // if hitting tail and not eating, it's okay because tail shifts
      if(!(nx === tail.x && ny === tail.y && !willEat)){
        endGame();
        return;
      }
    }

    // move
    snake.push({x:nx, y:ny});

    if(willEat){
      score += 10;
      elScore.textContent = score;
      if(score > best){
        best = score;
        localStorage.setItem(LS_KEY, String(best));
        elBest.textContent = best;
      }
      placeFood();
    } else {
      snake.shift();
    }
  }

  function endGame(){
    running = false;
    gameOver = true;
    updateStateText();
    showOverlay('Game Over', '按 R 重新開始，或按「開始」再來一局');
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // draw food
    drawCell(food.x, food.y, '#ff4d6d', true);

    // draw snake
    for(let i=0; i<snake.length; i++){
      const p = snake[i];
      const t = i / Math.max(1, (snake.length-1));
      const col = lerpColor('#44d86f', '#7CFF6B', t);
      const isHead = i === snake.length - 1;
      drawCell(p.x, p.y, col, isHead);
    }
  }

  function drawCell(x,y,color,glow=false){
    const px = x * cell;
    const py = y * cell;
    const pad = Math.max(2, Math.floor(cell * 0.12));
    const r = Math.max(6, Math.floor(cell * 0.25));

    if(glow){
      ctx.save();
      ctx.shadowColor = color;
      ctx.shadowBlur = 14;
      roundRect(px+pad, py+pad, cell-pad*2, cell-pad*2, r, color);
      ctx.restore();
    } else {
      roundRect(px+pad, py+pad, cell-pad*2, cell-pad*2, r, color);
    }
  }

  function roundRect(x,y,w,h,r,fill){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y,   x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x,   y+h, r);
    ctx.arcTo(x,   y+h, x,   y,   r);
    ctx.arcTo(x,   y,   x+w, y,   r);
    ctx.closePath();
    ctx.fillStyle = fill;
    ctx.fill();
    // subtle highlight
    ctx.strokeStyle = 'rgba(255,255,255,.10)';
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  function lerpColor(a,b,t){
    const pa = hexToRgb(a), pb = hexToRgb(b);
    const r = Math.round(pa.r + (pb.r-pa.r)*t);
    const g = Math.round(pa.g + (pb.g-pa.g)*t);
    const bl= Math.round(pa.b + (pb.b-pa.b)*t);
    return `rgb(${r},${g},${bl})`;
  }
  function hexToRgb(hex){
    const h = hex.replace('#','');
    const bigint = parseInt(h.length===3 ? h.split('').map(c=>c+c).join('') : h, 16);
    return { r:(bigint>>16)&255, g:(bigint>>8)&255, b:bigint&255 };
  }

  // main loop (fixed timestep via accumulator)
  function loop(ts){
    const dt = (ts - lastTime) / 1000 || 0;
    lastTime = ts;

    const targetStep = 1 / speed;

    if(running && !gameOver){
      acc += dt;
      while(acc >= targetStep){
        step();
        acc -= targetStep;
      }
    }

    draw();
    requestAnimationFrame(loop);
  }

  // input: keyboard
  window.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    if(k === ' '){
      e.preventDefault();
      toggle();
      return;
    }
    if(k === 'r'){
      reset();
      return;
    }
    // WASD / arrows
    if(k === 'arrowup' || k === 'w') setDir(0,-1);
    else if(k === 'arrowdown' || k === 's') setDir(0,1);
    else if(k === 'arrowleft' || k === 'a') setDir(-1,0);
    else if(k === 'arrowright' || k === 'd') setDir(1,0);
  });

  function setDir(x,y){
    // buffer direction; prevent reverse handled in step()
    nextDir = {x,y};
    if(!running && !gameOver){
      // allow "first move" to start the game
      running = true;
      updateStateText();
      hideOverlay();
    }
  }

  // UI controls
  speedSlider.addEventListener('input', () => {
    speed = Number(speedSlider.value);
    speedVal.textContent = speed;
  });
  cellSlider.addEventListener('input', () => {
    updateGrid();
    reset();
  });

  btnToggle.addEventListener('click', toggle);
  btnRestart.addEventListener('click', () => reset());

  // touch swipe support
  let touchStart = null;
  canvas.addEventListener('touchstart', (e) => {
    const t = e.changedTouches[0];
    touchStart = {x: t.clientX, y: t.clientY, time: Date.now()};
  }, {passive:true});

  canvas.addEventListener('touchend', (e) => {
    if(!touchStart) return;
    const t = e.changedTouches[0];
    const dx = t.clientX - touchStart.x;
    const dy = t.clientY - touchStart.y;
    const adx = Math.abs(dx), ady = Math.abs(dy);
    if(Math.max(adx,ady) < 20) return;

    if(adx > ady){
      setDir(dx > 0 ? 1 : -1, 0);
    } else {
      setDir(0, dy > 0 ? 1 : -1);
    }
    touchStart = null;
  }, {passive:true});

  // init
  speedVal.textContent = speed;
  updateGrid();
  reset();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>