<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>æ¥µé™è²ªé£Ÿè›‡ï¼šå…¨è¢å¹•é©é…ç‰ˆ</title>
  <style>
    :root { --bg: #0b1220; --accent: #4cc9f0; --grid: rgba(60, 80, 120, 0.2); }
    html, body {
      margin: 0; padding: 0; width: 100%; height: 100%;
      background: radial-gradient(circle at center, #152853 0%, var(--bg) 90%);
      font-family: system-ui, -apple-system, sans-serif; color: #fff; 
      overflow: hidden; touch-action: none; user-select: none;
      display: flex; flex-direction: column;
    }
    
    /* 1. é ‚éƒ¨å€å¡Š (å›ºå®šé«˜åº¦) */
    header {
      padding: 0 15px; 
      display: flex; justify-content: space-between; align-items: center;
      background: rgba(0,0,0,0.3); border-bottom: 1px solid rgba(255,255,255,0.1);
      flex-shrink: 0; height: 50px; box-sizing: border-box; z-index: 20;
    }
    .header-left { display: flex; align-items: center; gap: 10px; }
    .home-btn {
        text-decoration: none; font-size: 18px; color: #fff;
        background: rgba(255,255,255,0.1); width: 32px; height: 32px;
        display: flex; align-items: center; justify-content: center;
        border-radius: 8px; border: 1px solid rgba(255,255,255,0.2);
    }
    .score-box { font-size: 18px; font-weight: 800; color: var(--accent); font-family: monospace; }

    /* 2. éŠæˆ²ä¸»å€åŸŸ (å½ˆæ€§ä¼¸ç¸®ï¼Œä½”æ»¿å‰©é¤˜ç©ºé–“) */
    .game-wrapper {
        flex: 1; /* åƒæ‰å‰©ä¸‹çš„æ‰€æœ‰é«˜åº¦ */
        width: 100%;
        display: flex; align-items: center; justify-content: center;
        position: relative;
        overflow: hidden;
        padding: 10px; /* ç•™ä¸€é»é‚Šè· */
        box-sizing: border-box;
    }

    /* ç•«å¸ƒå®¹å™¨ï¼šä¸è¨­å›ºå®šå¯¬é«˜ï¼Œç”± JS å‹•æ…‹æ±ºå®š */
    .game-container { 
        position: relative; 
        border-radius: 4px; overflow: hidden; 
        box-shadow: 0 0 20px rgba(76, 201, 240, 0.15);
        border: 2px solid rgba(255,255,255,0.15);
        background: #061022;
        z-index: 1;
    }
    
    canvas {
      display: block;
      /* ç¶²æ ¼ç·š */
      background-image: linear-gradient(var(--grid) 1px, transparent 1px), linear-gradient(90deg, var(--grid) 1px, transparent 1px);
      /* background-size ç”± JS å‹•æ…‹è¨­å®š */
    }

    /* UI å±¤ */
    #ui-layer {
      position: absolute; inset: 0; 
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      z-index: 100; pointer-events: none;
    }

    h2 { 
      margin: 0 0 15px 0; font-size: 36px; color: #ff4d6d; 
      text-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
      display: none; pointer-events: auto;
    }
    
    button#startBtn {
      padding: 12px 40px; font-size: 18px; font-weight: bold;
      background: var(--accent); border: none; border-radius: 50px;
      color: #000; cursor: pointer; box-shadow: 0 0 20px var(--accent);
      pointer-events: auto; transition: transform 0.1s;
    }
    button#startBtn:active { transform: scale(0.95); }

    /* 3. åº•éƒ¨æ–æ¡¿å€ (å›ºå®šé«˜åº¦) */
    .controls-area {
        height: 180px; width: 100%;
        display: flex; justify-content: center; align-items: center;
        background: rgba(0,0,0,0.15);
        flex-shrink: 0; /* ç¦æ­¢è¢«å£“ç¸® */
        position: relative;
        z-index: 50;
    }

    .joystick-base {
        width: 120px; height: 120px;
        background: rgba(255, 255, 255, 0.05);
        border: 2px solid rgba(255, 255, 255, 0.1);
        border-radius: 50%;
        position: relative;
        display: flex; justify-content: center; align-items: center;
    }

    .joystick-knob {
        width: 50px; height: 50px;
        background: var(--accent);
        border-radius: 50%;
        position: absolute;
        box-shadow: 0 0 15px var(--accent);
        pointer-events: none;
        transition: transform 0.08s ease-out;
    }

    .joy-arrow { 
        position: absolute; color: rgba(255,255,255,0.2); 
        font-size: 14px; font-weight: bold; pointer-events: none;
    }
    .ja-up { top: 8px; } .ja-down { bottom: 8px; } 
    .ja-left { left: 8px; } .ja-right { right: 8px; }

    @media (min-width: 800px) { .controls-area { display: none; } }
  </style>
</head>
<body>

  <header>
    <div class="header-left">
        <a href="index.html" class="home-btn">ğŸ </a>
        <div style="font-weight:900; letter-spacing:1px; margin-left:10px;">SNAKE</div>
    </div>
    <div class="score-box">SCORE: <span id="scoreVal">0</span></div>
  </header>

  <div class="game-wrapper">
      <div class="game-container" id="gContainer">
        <canvas id="snakeCanvas"></canvas>
        <div id="ui-layer">
          <h2 id="msg-title">GAME OVER</h2>
          <button id="startBtn">START GAME</button>
        </div>
      </div>
  </div>

  <div class="controls-area">
      <div class="joystick-base" id="joyBase">
          <div class="joy-arrow ja-up">â–²</div>
          <div class="joy-arrow ja-down">â–¼</div>
          <div class="joy-arrow ja-left">â—€</div>
          <div class="joy-arrow ja-right">â–¶</div>
          <div class="joystick-knob" id="joyKnob"></div>
      </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('snakeCanvas');
  const ctx = canvas.getContext('2d');
  const container = document.getElementById('gContainer');
  const scoreEl = document.getElementById('scoreVal');
  const msgTitle = document.getElementById('msg-title');
  const startBtn = document.getElementById('startBtn');
  
  // éŠæˆ²æ ¸å¿ƒè®Šæ•¸
  let cols, rows;   // ç¾åœ¨é€™æ˜¯å‹•æ…‹è¨ˆç®—çš„ï¼Œä¸æ˜¯å›ºå®šçš„
  let cellSize = 18; // æ¯å€‹æ ¼å­çš„å¤§å° (px)ï¼Œæœƒæ ¹æ“šè§£æåº¦å¾®èª¿
  let dpr;
  
  let snake = [], food = {};
  let dir = {x:0, y:-1}; 
  let inputQueue = [];
  let score = 0, isRunning = false;
  let gameLoopTimeout = null;
  let audioCtx;

  // éŸ³æ•ˆ
  function playNote(f, type='sine', d=0.1) {
    if(!audioCtx || audioCtx.state !== 'running') return;
    try {
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = type; o.frequency.setValueAtTime(f, audioCtx.currentTime);
        g.gain.setValueAtTime(0.1, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + d);
        o.connect(g); g.connect(audioCtx.destination);
        o.start(); o.stop(audioCtx.currentTime + d);
    } catch(e){}
  }

  // === é—œéµä¿®æ­£ï¼šå‹•æ…‹ç¶²æ ¼è¨ˆç®— ===
  function resize() {
    dpr = window.devicePixelRatio || 1;
    
    // 1. å–å¾— wrapper ç›®å‰å¯ç”¨çš„å¯¬é«˜ (é€™æ˜¯æœ€æº–ç¢ºçš„å‰©é¤˜ç©ºé–“)
    const wrapper = document.querySelector('.game-wrapper');
    const availW = wrapper.clientWidth - 20; // æ‰£æ‰ padding
    const availH = wrapper.clientHeight - 20;
    
    // 2. è¨­å®šç›®æ¨™æ ¼å­å¤§å° (ä¾‹å¦‚ç´„ 20px ä¸€æ ¼)
    const targetCellSize = 20; 
    
    // 3. ç®—å‡ºæ©«å‘å’Œç›´å‘æœ€å¤šèƒ½æ”¾å¹¾æ ¼
    cols = Math.floor(availW / targetCellSize);
    rows = Math.floor(availH / targetCellSize);
    
    // 4. åæ¨æº–ç¢ºçš„ç•«å¸ƒå¤§å° (å¿…é ˆæ˜¯æ ¼å­çš„æ•´æ•¸å€ï¼Œæ‰ä¸æœƒæœ‰åŠæ ¼)
    const finalW = cols * targetCellSize;
    const finalH = rows * targetCellSize;
    
    // 5. è¨­å®š CSS å°ºå¯¸
    container.style.width = finalW + "px";
    container.style.height = finalH + "px";
    
    // 6. è¨­å®š Canvas è§£æåº¦
    canvas.width = finalW * dpr;
    canvas.height = finalH * dpr;
    ctx.scale(dpr, dpr);
    
    // 7. æ›´æ–°å¯¦éš›ä½¿ç”¨çš„æ ¼å­å¤§å° (çµ¦ç¹ªåœ–ç”¨)
    cellSize = targetCellSize;
    document.documentElement.style.setProperty('--cell', cellSize + 'px');
    
    // 8. å¦‚æœåœ¨æš«åœç‹€æ…‹ï¼Œé‡ç•«ç•«é¢ä»¥å…é»‘å±
    if(!isRunning && snake.length > 0) draw();
  }
  
  // ç›£è½è¢å¹•æ—‹è½‰æˆ–èª¿æ•´å¤§å°
  window.addEventListener('resize', () => {
    resize();
    // å¦‚æœé‡è¨­å¤§å°æ™‚æ­£åœ¨ç©ï¼Œå¯èƒ½éœ€è¦æš«åœæˆ–é‡ç½®ï¼Œé€™è£¡é¸æ“‡é‡ç•«
    if(!isRunning) draw(); 
  });

  // ä¿è­‰é£Ÿç‰©ç”Ÿæˆ
  function spawnFood() {
    let valid = false;
    let attempts = 0;
    let newFood = {};

    while(!valid && attempts < 100) {
        newFood = { 
            x: Math.floor(Math.random()*cols), 
            y: Math.floor(Math.random()*rows), 
            type: Math.random()<0.1?'star':(Math.random()<0.2?'pill':'normal') 
        };
        valid = !snake.some(p => p.x === newFood.x && p.y === newFood.y);
        attempts++;
    }

    if (!valid) {
        for(let r=0; r<rows; r++) {
            for(let c=0; c<cols; c++) {
                if (!snake.some(p => p.x === c && p.y === r)) {
                    newFood = { x: c, y: r, type: 'normal' };
                    valid = true;
                    break;
                }
            }
            if(valid) break;
        }
    }

    if (valid) food = newFood;
  }

  function initGame() {
    resize(); // ç¢ºä¿é–‹å§‹å‰å°ºå¯¸æ˜¯å°çš„
    score = 0; scoreEl.textContent = score;
    
    // è›‡å‡ºç”Ÿåœ¨ä¸­é–“
    const midX = Math.floor(cols/2);
    const midY = Math.floor(rows/2);
    
    snake = [];
    // åˆå§‹ 5 æ ¼
    for(let i=0; i<5; i++) {
        // ç¢ºä¿åˆå§‹è›‡èº«ä¸æœƒè¶…å‡ºä¸‹æ–¹é‚Šç•Œ (é›–ç„¶æ©Ÿç‡å¾ˆä½)
        if (midY + i < rows) {
            snake.push({x: midX, y: midY + i});
        }
    }
    
    dir = {x:0, y:-1}; 
    inputQueue = [];
    
    spawnFood(); 
    
    if(gameLoopTimeout) clearTimeout(gameLoopTimeout);
    isRunning = false;
    
    draw(); 
  }

  function startGame() {
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if(audioCtx.state === 'suspended') audioCtx.resume();

    startBtn.style.display = 'none';
    msgTitle.style.display = 'none';
    
    initGame();
    isRunning = true;
    update();
  }

  function gameOver() {
    playNote(100, 'sawtooth', 0.5); 
    isRunning = false;
    
    msgTitle.style.display = 'block';
    startBtn.innerText = "TRY AGAIN";
    startBtn.style.display = 'block';
  }

  function update() {
    if(!isRunning) return;

    if(inputQueue.length > 0) {
        const next = inputQueue.shift();
        if(next.x !== -dir.x && next.y !== -dir.y) dir = next;
    }

    const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

    // === é‚Šç•Œæª¢æŸ¥ (ä½¿ç”¨å‹•æ…‹è¨ˆç®—çš„ cols å’Œ rows) ===
    // é€™è£¡ä¿è­‰äº†è›‡çµ•å°ä¸æœƒè·‘å‡ºç•«é¢
    if(head.x < 0 || head.x >= cols || head.y < 0 || head.y >= rows || snake.some(p=>p.x===head.x && p.y===head.y)) {
      gameOver();
      return;
    }

    snake.unshift(head);

    if(head.x===food.x && head.y===food.y) {
      if(food.type==='star') { score+=30; playNote(800, 'square'); }
      else if(food.type==='pill') { 
          score+=5; playNote(400, 'sine'); 
          if(snake.length > 4) { snake.pop(); snake.pop(); }
          else snake.pop();
      }
      else { score+=10; playNote(600, 'triangle'); }
      
      scoreEl.textContent = score; 
      spawnFood();
    } else {
      snake.pop();
    }

    draw();
    
    const speed = Math.max(50, 90 - Math.sqrt(score) * 3);
    gameLoopTimeout = setTimeout(update, speed);
  }

  function draw() {
    ctx.clearRect(0,0,canvas.width/dpr, canvas.height/dpr);
    
    if(food && food.x !== undefined) {
        const fx=food.x*cellSize, fy=food.y*cellSize;
        const p=cellSize*0.15, s=cellSize-p*2;
        
        if(food.type==='star') ctx.fillStyle = '#ffcf33'; 
        else if(food.type==='pill') ctx.fillStyle = '#4cc9f0'; 
        else ctx.fillStyle = '#ff3333'; 
        
        ctx.shadowBlur = 10; ctx.shadowColor = ctx.fillStyle;
        
        ctx.beginPath(); 
        if(food.type === 'star') ctx.arc(fx+cellSize/2, fy+cellSize/2, s/2, 0, Math.PI*2);
        else ctx.roundRect(fx+p, fy+p, s, s, 4); 
        ctx.fill();
        ctx.shadowBlur = 0;
    }

    snake.forEach((p, i) => {
      ctx.fillStyle = i===0 ? '#fff' : (i%2===0 ? '#7CFF6B' : '#5CE64A');
      const x=p.x*cellSize, y=p.y*cellSize;
      const gap = 0.5;
      
      ctx.beginPath(); 
      ctx.roundRect(x+gap, y+gap, cellSize-gap*2, cellSize-gap*2, i===0?4:2); 
      ctx.fill();
      
      if(i===0) { 
        ctx.fillStyle='#000';
        const eyeOff = cellSize*0.25;
        const eyeSize = cellSize*0.12;
        const cx = x + cellSize/2, cy = y + cellSize/2;
        ctx.beginPath(); 
        ctx.arc(cx + dir.y*eyeOff + dir.x*eyeOff, cy + dir.x*eyeOff + dir.y*eyeOff, eyeSize, 0, Math.PI*2); 
        ctx.arc(cx - dir.y*eyeOff + dir.x*eyeOff, cy - dir.x*eyeOff + dir.y*eyeOff, eyeSize, 0, Math.PI*2);
        ctx.fill();
      }
    });
  }

  // === è¼¸å…¥è™•ç† ===
  const handleInput = (x, y) => { 
    if(!isRunning) return;
    const lastPendingDir = inputQueue.length > 0 ? inputQueue[inputQueue.length-1] : dir;
    if(x === -lastPendingDir.x && y === -lastPendingDir.y) return;
    if(x === lastPendingDir.x && y === lastPendingDir.y) return;
    if(inputQueue.length < 2) inputQueue.push({x, y});
  };

  const joyBase = document.getElementById('joyBase');
  const joyKnob = document.getElementById('joyKnob');
  let joyActive = false;
  let joyCenter = {x:0, y:0};
  const maxRadius = 40; 
  let lastJoyDir = {x:0, y:0};

  const updateJoystick = (clientX, clientY) => {
      const dx = clientX - joyCenter.x;
      const dy = clientY - joyCenter.y;
      const distance = Math.min(Math.sqrt(dx*dx + dy*dy), maxRadius);
      const angle = Math.atan2(dy, dx);
      const kx = Math.cos(angle) * distance;
      const ky = Math.sin(angle) * distance;
      joyKnob.style.transform = `translate(${kx}px, ${ky}px)`;

      if(distance > 15) {
          let newX = 0, newY = 0;
          if (Math.abs(dx) > Math.abs(dy)) newX = dx > 0 ? 1 : -1;
          else newY = dy > 0 ? 1 : -1;

          if(newX !== lastJoyDir.x || newY !== lastJoyDir.y) {
              handleInput(newX, newY);
              lastJoyDir = {x: newX, y: newY};
          }
      }
  };

  joyBase.addEventListener('touchstart', (e) => {
      e.preventDefault();
      joyActive = true;
      const rect = joyBase.getBoundingClientRect();
      joyCenter = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
      joyKnob.style.transition = 'none'; 
      updateJoystick(e.touches[0].clientX, e.touches[0].clientY);
  }, {passive: false});

  window.addEventListener('touchmove', (e) => {
      if(!joyActive) return;
      updateJoystick(e.touches[0].clientX, e.touches[0].clientY);
  }, {passive: false});

  window.addEventListener('touchend', (e) => {
      if(!joyActive) return;
      joyActive = false;
      joyKnob.style.transition = 'transform 0.1s ease-out';
      joyKnob.style.transform = `translate(0, 0)`;
      lastJoyDir = {x:0, y:0};
  });

  window.addEventListener('keydown', e => {
      if(['ArrowUp','w','W'].includes(e.key)) handleInput(0,-1);
      if(['ArrowDown','s','S'].includes(e.key)) handleInput(0,1);
      if(['ArrowLeft','a','A'].includes(e.key)) handleInput(-1,0);
      if(['ArrowRight','d','D'].includes(e.key)) handleInput(1,0);
      if(e.code === 'Space' && !isRunning) startGame();
  });

  startBtn.onclick = startGame;

  // ç¨‹å¼å…¥å£
  resize(); 
  initGame(); 

})();
</script>
</body>
</html>
