<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>æ¥µé™è²ªé£Ÿè›‡ï¼šçµ•å°ä¿®æ­£ç‰ˆ</title>
  <style>
    :root { --bg: #0b1220; --accent: #4cc9f0; }
    html, body {
      margin: 0; padding: 0; width: 100%; height: 100%;
      background: radial-gradient(circle at center, #152853 0%, var(--bg) 90%);
      font-family: system-ui, -apple-system, sans-serif; color: #fff; 
      overflow: hidden; touch-action: none; user-select: none;
      display: flex; flex-direction: column;
    }
    
    /* 1. é ‚éƒ¨è³‡è¨Šåˆ— */
    header {
      padding: 0 15px; 
      display: flex; justify-content: space-between; align-items: center;
      background: rgba(0,0,0,0.4); border-bottom: 1px solid rgba(255,255,255,0.1);
      flex-shrink: 0; height: 50px; box-sizing: border-box; z-index: 20;
    }
    .header-left { display: flex; align-items: center; gap: 10px; }
    .home-btn {
        text-decoration: none; font-size: 18px; color: #fff;
        background: rgba(255,255,255,0.1); width: 32px; height: 32px;
        display: flex; align-items: center; justify-content: center;
        border-radius: 8px; border: 1px solid rgba(255,255,255,0.2);
    }
    .score-box { font-size: 18px; font-weight: 800; color: var(--accent); font-family: monospace; }

    /* 2. éŠæˆ²ä¸»å€åŸŸ */
    .game-wrapper {
        flex: 1; /* åƒæ‰å‰©ä¸‹çš„æ‰€æœ‰é«˜åº¦ */
        width: 100%;
        display: flex; align-items: center; justify-content: center;
        position: relative;
        background: #000; /* ç•«å¸ƒèƒŒæ™¯é»‘ */
    }

    /* ç•«å¸ƒæœ¬èº« */
    canvas {
      display: block;
      background: #061022;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
    }

    /* UI å±¤ (é‡æ–°é–‹å§‹æŒ‰éˆ•) */
    #ui-layer {
      position: absolute; inset: 0; 
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      z-index: 100; pointer-events: none;
    }

    h2 { 
      margin: 0 0 20px 0; font-size: 40px; color: #ff4d6d; 
      text-shadow: 0 0 20px rgba(255, 0, 0, 1);
      display: none; pointer-events: auto; font-weight: 900;
    }
    
    button#startBtn {
      padding: 15px 50px; font-size: 22px; font-weight: bold;
      background: var(--accent); border: none; border-radius: 50px;
      color: #000; cursor: pointer; box-shadow: 0 0 30px var(--accent);
      pointer-events: auto; transition: transform 0.1s;
      display: block;
    }
    button#startBtn:active { transform: scale(0.95); }

    /* 3. åº•éƒ¨æ–æ¡¿å€ */
    .controls-area {
        height: 180px; width: 100%;
        display: flex; justify-content: center; align-items: center;
        background: rgba(255,255,255,0.05);
        border-top: 1px solid rgba(255,255,255,0.1);
        flex-shrink: 0; 
        position: relative;
        z-index: 50;
    }

    .joystick-base {
        width: 120px; height: 120px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        position: relative;
        display: flex; justify-content: center; align-items: center;
    }

    .joystick-knob {
        width: 50px; height: 50px;
        background: var(--accent);
        border-radius: 50%;
        position: absolute;
        box-shadow: 0 0 15px var(--accent);
        pointer-events: none;
        transition: transform 0.08s ease-out;
    }

    /* é›»è…¦ç‰ˆéš±è—æ–æ¡¿ */
    @media (min-width: 800px) { .controls-area { display: none; } }
  </style>
</head>
<body>

  <header>
    <div class="header-left">
        <a href="index.html" class="home-btn">ğŸ </a>
        <div style="font-weight:900; letter-spacing:1px; margin-left:10px;">SNAKE</div>
    </div>
    <div class="score-box">SCORE: <span id="scoreVal">0</span></div>
  </header>

  <div class="game-wrapper" id="gameWrapper">
      <canvas id="snakeCanvas"></canvas>
      <div id="ui-layer">
          <h2 id="msg-title">GAME OVER</h2>
          <button id="startBtn">START GAME</button>
      </div>
  </div>

  <div class="controls-area">
      <div class="joystick-base" id="joyBase">
          <div class="joystick-knob" id="joyKnob"></div>
      </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('snakeCanvas');
  const ctx = canvas.getContext('2d');
  const wrapper = document.getElementById('gameWrapper');
  const scoreEl = document.getElementById('scoreVal');
  const msgTitle = document.getElementById('msg-title');
  const startBtn = document.getElementById('startBtn');
  
  // æ ¸å¿ƒåƒæ•¸
  let cols, rows;
  const TARGET_CELL_SIZE = 20; // ç›®æ¨™æ ¼å­å¤§å°
  let cellSize = TARGET_CELL_SIZE;
  let dpr = window.devicePixelRatio || 1;
  
  let snake = [], food = {};
  let dir = {x:0, y:-1}; 
  let inputQueue = [];
  let score = 0, isRunning = false;
  let gameLoopId;
  let audioCtx;

  // éŸ³æ•ˆ
  function playNote(f, type='sine', d=0.1) {
    if(!audioCtx || audioCtx.state !== 'running') return;
    try {
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = type; o.frequency.setValueAtTime(f, audioCtx.currentTime);
        g.gain.setValueAtTime(0.1, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + d);
        o.connect(g); g.connect(audioCtx.destination);
        o.start(); o.stop(audioCtx.currentTime + d);
    } catch(e){}
  }

  // === é—œéµä¿®æ­£ï¼šç•«å¸ƒå°ºå¯¸è¨ˆç®— ===
  function resize() {
    // 1. å–å¾—å®¹å™¨å¯¦éš›åƒç´ å¤§å°
    const availW = wrapper.clientWidth;
    const availH = wrapper.clientHeight;
    
    // 2. è¨ˆç®—èƒ½æ”¾å¤šå°‘æ ¼ (ç„¡æ¢ä»¶æ¨å»ï¼Œä¿è­‰ä¸è¶…å‡º)
    cols = Math.floor(availW / TARGET_CELL_SIZE);
    rows = Math.floor(availH / TARGET_CELL_SIZE);
    
    // é¿å…å¤ªå°
    if(cols < 5) cols = 5;
    if(rows < 5) rows = 5;

    // 3. åæ¨ç•«å¸ƒåƒç´ å¤§å° (é€™å°±æ˜¯è›‡æ´»å‹•çš„é‚Šç•Œ)
    const cssW = cols * TARGET_CELL_SIZE;
    const cssH = rows * TARGET_CELL_SIZE;
    
    // 4. è¨­å®š Canvas é¡¯ç¤ºå°ºå¯¸ (CSS)
    canvas.style.width = cssW + "px";
    canvas.style.height = cssH + "px";
    
    // 5. è¨­å®š Canvas ç¹ªåœ–è§£æåº¦ (Pixel)
    canvas.width = cssW * dpr;
    canvas.height = cssH * dpr;
    
    // 6. ç¸®æ”¾ç¹ªåœ–ç’°å¢ƒï¼Œè®“é‚è¼¯åº§æ¨™ 1 = 1æ ¼
    ctx.setTransform(1, 0, 0, 1, 0, 0); // é‡ç½®çŸ©é™£
    ctx.scale(dpr, dpr);

    cellSize = TARGET_CELL_SIZE;
    
    // é‡ç½®éŠæˆ²ä½ç½® (å¦‚æœé‚„æ²’é–‹å§‹)
    if(!isRunning) initGame();
    else draw(); // å¦‚æœæ­£åœ¨ç©ï¼Œé‡ç•«ä»¥é©æ‡‰æ–°ç¶²æ ¼(å¯èƒ½æœƒæˆªæ–·è›‡ï¼Œä½†è‡³å°‘ä¸æœƒè·‘ç‰ˆ)
  }

  // ç”Ÿæˆé£Ÿç‰©
  function spawnFood() {
    let valid = false;
    // æš´åŠ›æœå°‹æ³•ï¼šç¢ºä¿ä¸€å®šæœ‰ä½ç½®
    // å…ˆå˜—è©¦éš¨æ©Ÿ 50 æ¬¡
    for(let i=0; i<50; i++) {
        let tx = Math.floor(Math.random() * cols);
        let ty = Math.floor(Math.random() * rows);
        if(!snake.some(p => p.x === tx && p.y === ty)) {
            food = {x: tx, y: ty, type: Math.random()<0.1?'star':(Math.random()<0.2?'pill':'normal')};
            valid = true;
            break;
        }
    }
    // å¦‚æœéš¨æ©Ÿå¤±æ•—ï¼Œç›´æ¥æƒæ
    if(!valid) {
        for(let r=0; r<rows; r++) {
            for(let c=0; c<cols; c++) {
                if(!snake.some(p => p.x === c && p.y === r)) {
                    food = {x: c, y: r, type: 'normal'};
                    valid = true;
                    break;
                }
            }
            if(valid) break;
        }
    }
  }

  // åˆå§‹åŒ–ç‹€æ…‹
  function initGame() {
    score = 0; scoreEl.textContent = "0";
    snake = [];
    const midX = Math.floor(cols/2);
    const midY = Math.floor(rows/2);
    // ç”¢ç”Ÿ 5 æ ¼è›‡
    for(let i=0; i<5; i++) {
        // ç¢ºä¿ä¸è¶…ç•Œ
        if(midY + i < rows) snake.push({x: midX, y: midY + i});
    }
    dir = {x:0, y:-1}; 
    inputQueue = [];
    spawnFood();
    draw(); // ç•«ç¬¬ä¸€å¹€
  }

  function startGame() {
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if(audioCtx.state === 'suspended') audioCtx.resume();

    startBtn.style.display = 'none';
    msgTitle.style.display = 'none';
    
    initGame();
    isRunning = true;
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
  }

  function gameOver() {
    isRunning = false;
    playNote(100, 'sawtooth', 0.5);
    msgTitle.style.display = 'block';
    startBtn.innerText = "TRY AGAIN";
    startBtn.style.display = 'block';
  }

  let lastTime = 0;
  let moveInterval = 100; // åˆå§‹é€Ÿåº¦ ms

  function gameLoop(timestamp) {
    if(!isRunning) return;
    
    // è¨ˆç®—é€Ÿåº¦ (åˆ†æ•¸è¶Šé«˜è¶Šå¿«ï¼Œæœ€ä½ 50ms)
    moveInterval = Math.max(50, 100 - Math.sqrt(score) * 4);

    if (timestamp - lastTime > moveInterval) {
        update();
        lastTime = timestamp;
    }
    
    // ç¹ªåœ–ä¸ç”¨é™é »ï¼Œä¿æŒ 60fps æµæš¢æ„Ÿ
    draw(); 
    requestAnimationFrame(gameLoop);
  }

  function update() {
    // è™•ç†è¼¸å…¥
    if(inputQueue.length > 0) {
        const next = inputQueue.shift();
        if(next.x !== -dir.x && next.y !== -dir.y) dir = next;
    }

    const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

    // === åš´æ ¼é‚Šç•Œæª¢æŸ¥ ===
    // åªè¦ head.x æˆ– head.y è¶…å‡º 0 ~ cols/rows ç¯„åœï¼Œç›´æ¥åˆ¤æ­»
    if(head.x < 0 || head.x >= cols || head.y < 0 || head.y >= rows) {
        gameOver();
        return;
    }
    
    // æ’èº«é«”æª¢æŸ¥
    if(snake.some(p => p.x === head.x && p.y === head.y)) {
        gameOver();
        return;
    }

    snake.unshift(head);

    // åƒé£Ÿç‰©
    if(head.x === food.x && head.y === food.y) {
        if(food.type==='star') { score+=30; playNote(800, 'square'); }
        else if(food.type==='pill') { 
            score+=5; playNote(400, 'sine'); 
            if(snake.length > 3) { snake.pop(); snake.pop(); } // ç¸®çŸ­
            else snake.pop();
        }
        else { score+=10; playNote(600, 'triangle'); }
        
        scoreEl.textContent = score;
        spawnFood();
    } else {
        snake.pop();
    }
  }

  // === é—œéµä¿®æ­£ï¼šæ‰‹å‹•ç¹ªè£½ç¶²æ ¼ (ä¿è­‰æœ‰æ–¹æ ¼) ===
  function draw() {
    // æ¸…é™¤èƒŒæ™¯
    ctx.fillStyle = '#061022';
    ctx.fillRect(0, 0, cols * cellSize, rows * cellSize);

    // 1. ç¹ªè£½ç¶²æ ¼ç·š (ç”¨ JS ç•«ï¼Œä¸ç”¨ CSS)
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    // ç•«ç›´ç·š
    for(let c=0; c<=cols; c++) {
        ctx.moveTo(c * cellSize, 0);
        ctx.lineTo(c * cellSize, rows * cellSize);
    }
    // ç•«æ©«ç·š
    for(let r=0; r<=rows; r++) {
        ctx.moveTo(0, r * cellSize);
        ctx.lineTo(cols * cellSize, r * cellSize);
    }
    ctx.stroke();

    // 2. ç•«é‚Šæ¡† (ç´…è‰²è­¦æˆ’ç·šï¼Œè®“ä½ çŸ¥é“é‚Šç•Œåœ¨å“ª)
    ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
    ctx.lineWidth = 2;
    ctx.strokeRect(0, 0, cols * cellSize, rows * cellSize);

    // 3. ç•«é£Ÿç‰©
    const fx = food.x * cellSize;
    const fy = food.y * cellSize;
    const pad = cellSize * 0.15;
    const size = cellSize - pad * 2;
    
    if(food.type === 'star') ctx.fillStyle = '#ffcf33';
    else if(food.type === 'pill') ctx.fillStyle = '#4cc9f0';
    else ctx.fillStyle = '#ff3333';
    
    // ç°¡å–®ç™¼å…‰
    ctx.shadowBlur = 10; ctx.shadowColor = ctx.fillStyle;
    ctx.beginPath();
    if(food.type === 'star') ctx.arc(fx + cellSize/2, fy + cellSize/2, size/2, 0, Math.PI*2);
    else ctx.fillRect(fx + pad, fy + pad, size, size);
    ctx.fill();
    ctx.shadowBlur = 0;

    // 4. ç•«è›‡
    snake.forEach((p, i) => {
        const sx = p.x * cellSize;
        const sy = p.y * cellSize;
        const sGap = 1; // è›‡èº«ç¸«éš™
        
        ctx.fillStyle = (i === 0) ? '#ffffff' : ((i%2===0)?'#7CFF6B':'#5CE64A');
        ctx.fillRect(sx + sGap, sy + sGap, cellSize - sGap*2, cellSize - sGap*2);
        
        // çœ¼ç›
        if(i === 0) {
            ctx.fillStyle = '#000';
            const eyeSize = cellSize * 0.15;
            const center = cellSize / 2;
            const offset = cellSize * 0.2;
            // ç°¡åŒ–çœ¼ç›ç•«æ³•
            ctx.fillRect(sx + center - eyeSize + dir.x*offset, sy + center - eyeSize + dir.y*offset, eyeSize*2, eyeSize*2);
        }
    });
  }

  // === è¼¸å…¥è™•ç† ===
  const handleInput = (x, y) => { 
    if(!isRunning) return;
    const lastDir = inputQueue.length > 0 ? inputQueue[inputQueue.length-1] : dir;
    if(x === -lastDir.x && y === -lastDir.y) return; // ä¸èƒ½å›é ­
    if(x === lastDir.x && y === lastDir.y) return;   // åŒæ–¹å‘å¿½ç•¥
    if(inputQueue.length < 2) inputQueue.push({x, y});
  };

  // æ–æ¡¿é‚è¼¯
  const joyBase = document.getElementById('joyBase');
  const joyKnob = document.getElementById('joyKnob');
  let joyActive = false;
  let joyCenter = {x:0, y:0};
  let lastJoyDir = {x:0, y:0};

  const updateJoystick = (cx, cy) => {
      const dx = cx - joyCenter.x;
      const dy = cy - joyCenter.y;
      const dist = Math.min(Math.sqrt(dx*dx + dy*dy), 40); // æœ€å¤§åŠå¾‘
      const angle = Math.atan2(dy, dx);
      
      const kx = Math.cos(angle) * dist;
      const ky = Math.sin(angle) * dist;
      joyKnob.style.transform = `translate(${kx}px, ${ky}px)`;

      if(dist > 10) { // æ­»å€
          let nx = 0, ny = 0;
          if(Math.abs(dx) > Math.abs(dy)) nx = dx>0 ? 1 : -1;
          else ny = dy>0 ? 1 : -1;
          
          if(nx !== lastJoyDir.x || ny !== lastJoyDir.y) {
              handleInput(nx, ny);
              lastJoyDir = {x: nx, y: ny};
          }
      }
  };

  joyBase.addEventListener('touchstart', (e) => {
      e.preventDefault();
      joyActive = true;
      const r = joyBase.getBoundingClientRect();
      joyCenter = {x: r.left + r.width/2, y: r.top + r.height/2};
      joyKnob.style.transition = 'none';
      updateJoystick(e.touches[0].clientX, e.touches[0].clientY);
  }, {passive: false});

  window.addEventListener('touchmove', (e) => {
      if(!joyActive) return;
      updateJoystick(e.touches[0].clientX, e.touches[0].clientY);
  }, {passive: false});

  window.addEventListener('touchend', (e) => {
      joyActive = false;
      joyKnob.style.transition = '0.1s';
      joyKnob.style.transform = 'translate(0,0)';
      lastJoyDir = {x:0, y:0};
  });

  // éµç›¤
  window.addEventListener('keydown', e => {
      if(['ArrowUp','w'].includes(e.key)) handleInput(0,-1);
      if(['ArrowDown','s'].includes(e.key)) handleInput(0,1);
      if(['ArrowLeft','a'].includes(e.key)) handleInput(-1,0);
      if(['ArrowRight','d'].includes(e.key)) handleInput(1,0);
      if(e.code === 'Space' && !isRunning) startBtn.click();
  });

  window.addEventListener('resize', () => {
      resize();
  });

  startBtn.onclick = startGame;
  
  // å•Ÿå‹•
  resize();

})();
</script>
</body>
</html>
