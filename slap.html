<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Slap Master | å·´æŒå¤§å¸«</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body { 
            font-family: 'Arial Black', sans-serif; 
            background: linear-gradient(135deg, #f6d365 0%, #fda085 100%); 
            display: flex; 
            flex-direction: column; 
            min-height: 100vh;
            overflow: hidden; /* ç¦æ­¢æ²å‹• */
            touch-action: none; /* ç¦æ­¢æ‰‹æ©Ÿç¸®æ”¾èˆ‡æ²å‹• */
        }

        /* é ‚éƒ¨åˆ— */
        header {
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
        }
        .home-btn {
            text-decoration: none;
            font-size: 24px;
            background: rgba(255,255,255,0.3);
            width: 45px; height: 45px;
            display: flex; align-items: center; justify-content: center;
            border-radius: 50%;
            border: 2px solid #fff;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            transition: transform 0.1s;
        }
        .home-btn:active { transform: scale(0.9); }
        
        .score-board {
            font-size: 32px;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
            background: rgba(0,0,0,0.2);
            padding: 5px 20px;
            border-radius: 20px;
        }

        /* éŠæˆ²ç•«å¸ƒ */
        #game-container {
            flex: 1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer; /* è®“æ»‘é¼ è®Šæˆæ‰‹æŒ‡ */
        }

        canvas { 
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
        }

        /* æç¤ºæ–‡å­— */
        .tips {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.8);
            font-size: 14px;
            pointer-events: none;
            animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }
    </style>
</head>
<body>

    <header>
        <a href="index.html" class="home-btn">ğŸ </a>
        <div class="score-board">SCORE: <span id="score">0</span></div>
    </header>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="tips">é»æ“Šè¢å¹•ç”¨åŠ›æ‰“ï¼ (é–‹å•Ÿè²éŸ³é«”é©—æ›´ä½³)</div>
    </div>

    <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');

    // --- éŠæˆ²è®Šæ•¸ ---
    let score = 0;
    let width, height;
    
    // ä¸»è§’è‡‰çš„ç‹€æ…‹
    let face = {
        scale: 1,
        rotation: 0,
        expression: 'ğŸ˜', // é è¨­è¡¨æƒ…ï¼šæ¬ æ‰“
        hitTimer: 0
    };

    // æ‰‹æŒèˆ‡ç‰¹æ•ˆåˆ—è¡¨
    let hands = []; // å­˜æ”¾å·´æŒå‹•ç•«
    let texts = []; // å­˜æ”¾ "å•ªï¼" æ–‡å­—
    
    // --- åˆå§‹åŒ–èˆ‡ RWD ---
    function resize() {
        width = canvas.width = canvas.clientWidth;
        height = canvas.height = canvas.clientHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- éŸ³æ•ˆå¼•æ“ (åˆæˆå•ªå•ªè²) ---
    let audioCtx;
    let noiseBuffer;

    function initAudio() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            // é å…ˆç”Ÿæˆç™½å™ªéŸ³ Buffer (0.5ç§’)
            const bufferSize = audioCtx.sampleRate * 0.5;
            noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = noiseBuffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                // ç™½å™ªéŸ³
                data[i] = Math.random() * 2 - 1;
            }
        }
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
    }

    function playSlapSound() {
        if (!audioCtx) return;

        const source = audioCtx.createBufferSource();
        source.buffer = noiseBuffer;

        // æ¿¾æ³¢å™¨ï¼šè®“è²éŸ³è½èµ·ä¾†åƒæ‰“åœ¨è‚‰ä¸Š (Lowpass Filter)
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 1000; // èª¿æ•´é€™å€‹é »ç‡æ”¹è®Šæ‰“æ“Šè³ªæ„Ÿ

        // éŸ³é‡åŒ…çµ¡ (Envelope)ï¼šç¬é–“å¤§è²ç„¶å¾Œå¿«é€Ÿæ¶ˆå¤±
        const gainNode = audioCtx.createGain();
        // â˜…â˜…â˜… é€™è£¡è¨­å®šæœ€å¤§éŸ³é‡ (1.0) â˜…â˜…â˜…
        gainNode.gain.setValueAtTime(1.0, audioCtx.currentTime); 
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15); // 0.15ç§’å…§æ¶ˆå¤±

        // é€£æ¥ï¼šSource -> Filter -> Gain -> Output
        source.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        // ç¨å¾®éš¨æ©ŸåŒ–éŸ³èª¿ï¼Œè®“æ¯æ¬¡å·´æŒè²éŸ³ä¸åŒ
        source.playbackRate.value = 0.8 + Math.random() * 0.4;
        
        source.start();
    }

    // --- ç¹ªåœ–é‚è¼¯ ---
    function update() {
        // è‡‰éƒ¨æ¢å¾©é‚è¼¯
        if (face.hitTimer > 0) {
            face.hitTimer--;
            // éœ‡å‹•æ•ˆæœ
            face.rotation = (Math.random() - 0.5) * 0.5;
            face.scale = 1.1; 
        } else {
            face.rotation = 0;
            face.scale = 1;
            face.expression = 'ğŸ˜'; // æ¢å¾©æ¬ æ‰“è¡¨æƒ…
        }

        // æ›´æ–°æ‰‹æŒå‹•ç•«
        for (let i = hands.length - 1; i >= 0; i--) {
            hands[i].life -= 0.08; // æ¶ˆå¤±é€Ÿåº¦
            hands[i].scale -= 0.02;
            if (hands[i].life <= 0) hands.splice(i, 1);
        }

        // æ›´æ–°æ–‡å­—ç‰¹æ•ˆ
        for (let i = texts.length - 1; i >= 0; i--) {
            texts[i].y -= 2; // å¾€ä¸Šé£„
            texts[i].life -= 0.03;
            if (texts[i].life <= 0) texts.splice(i, 1);
        }
    }

    function draw() {
        ctx.clearRect(0, 0, width, height);

        const centerX = width / 2;
        const centerY = height / 2;

        // 1. ç¹ªè£½è‡‰ (ä½¿ç”¨ Emojiï¼Œæ¸…æ™°åˆç”Ÿå‹•)
        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.rotate(face.rotation);
        ctx.scale(face.scale, face.scale);
        
        ctx.font = `${Math.min(width, height) * 0.4}px serif`; // æ ¹æ“šè¢å¹•å¤§å°èª¿æ•´è‡‰çš„å¤§å°
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(face.expression, 0, 0);
        ctx.restore();

        // 2. ç¹ªè£½æ‰‹æŒ
        hands.forEach(hand => {
            ctx.save();
            ctx.translate(hand.x, hand.y);
            ctx.rotate(hand.angle); // æ‰‹æŒéš¨æ©Ÿè§’åº¦
            ctx.scale(hand.scale, hand.scale);
            ctx.globalAlpha = hand.life;
            
            ctx.font = '80px serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('ğŸ‘‹', 0, 0);
            ctx.restore();
        });

        // 3. ç¹ªè£½ "å•ª!" æ–‡å­—ç‰¹æ•ˆ
        texts.forEach(text => {
            ctx.save();
            ctx.globalAlpha = text.life;
            ctx.font = `bold ${text.size}px Arial`;
            ctx.fillStyle = text.color;
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.textAlign = 'center';
            ctx.strokeText(text.str, text.x, text.y);
            ctx.fillText(text.str, text.x, text.y);
            ctx.restore();
        });
    }

    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    // --- äº’å‹•é‚è¼¯ ---
    function slap(x, y) {
        initAudio(); // ç¢ºä¿éŸ³æ•ˆå¼•æ“å•Ÿå‹•
        playSlapSound();

        score++;
        scoreEl.innerText = score;

        // è‡‰éƒ¨å—æ“Šåæ‡‰
        face.hitTimer = 10;
        // éš¨æ©Ÿåˆ‡æ›ç—›è‹¦è¡¨æƒ…
        const painFaces = ['ğŸ˜µ', 'ğŸ˜­', 'ğŸ¥´', 'ğŸ¤•', 'ğŸ¤®'];
        face.expression = painFaces[Math.floor(Math.random() * painFaces.length)];

        // ç”¢ç”Ÿæ‰‹æŒå‹•ç•«
        hands.push({
            x: x,
            y: y,
            angle: (Math.random() - 0.5) * 1, // éš¨æ©Ÿå‚¾æ–œ
            scale: 1.5,
            life: 1.0
        });

        // ç”¢ç”Ÿæ–‡å­—ç‰¹æ•ˆ
        const hitWords = ['å•ªï¼', 'SMACK!', 'PA!', 'å™—æ»‹!', 'å¥½ç—›!'];
        texts.push({
            x: x + (Math.random()-0.5)*50,
            y: y - 50,
            str: hitWords[Math.floor(Math.random() * hitWords.length)],
            color: `hsl(${Math.random() * 360}, 100%, 50%)`, // å½©è‰²å­—
            size: 40 + Math.random() * 20,
            life: 1.0
        });
    }

    // æ”¯æ´æ»‘é¼ é»æ“Š
    canvas.addEventListener('mousedown', e => {
        slap(e.clientX, e.clientY);
    });

    // æ”¯æ´æ‰‹æ©Ÿå¤šé»è§¸æ§ (å¯ä»¥é›™æ‰‹é€£æ‰“!)
    canvas.addEventListener('touchstart', e => {
        e.preventDefault(); // é˜²æ­¢ç•«é¢ç¸®æ”¾
        for (let i = 0; i < e.touches.length; i++) {
            slap(e.touches[i].clientX, e.touches[i].clientY);
        }
    }, { passive: false });

    // å•Ÿå‹•éŠæˆ²
    loop();

    </script>
</body>
</html>
