<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Piano | æ¥µé™è¡—æ©Ÿç‰ˆ</title>
    <style>
        /* === æ ¸å¿ƒæ¨£å¼ï¼šé–æ­»è§¸æ§ï¼Œé˜²æ­¢ç¸®æ”¾ === */
        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            background: #000; overflow: hidden; 
            font-family: 'Segoe UI', 'Roboto', sans-serif; 
            touch-action: none; user-select: none; -webkit-user-select: none;
        }
        
        #game-container { 
            position: relative; width: 100%; height: 100%; max-width: 650px; margin: 0 auto; 
            background: linear-gradient(to bottom, #120526 0%, #000 100%);
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.1); 
            transition: transform 0.05s;
        }
        
        canvas { display: block; width: 100%; height: 100%; }

        /* === ç€•æ­»ç´…æ¡†è­¦å‘Šç‰¹æ•ˆ === */
        #danger-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            box-shadow: inset 0 0 100px rgba(255, 0, 0, 0);
            pointer-events: none; z-index: 5;
            transition: box-shadow 0.3s;
        }
        .danger-active { animation: dangerPulse 0.8s infinite; }
        @keyframes dangerPulse { 
            0%, 100% { box-shadow: inset 0 0 50px rgba(255, 0, 0, 0.3); } 
            50% { box-shadow: inset 0 0 150px rgba(255, 0, 0, 0.8); } 
        }
        
        /* === UI å±¤ === */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; }
        
        /* é ‚éƒ¨è³‡è¨Šåˆ— */
        .hud { 
            width: 100%; padding: 60px 20px 10px 20px; /* ä¸Šæ–¹ç•™ç©ºé–“çµ¦ Home éµ */
            display: flex; justify-content: space-between; align-items: flex-end; 
            box-sizing: border-box; z-index: 10;
        }

        .life-group { text-align: left; }
        .life-bar { display: flex; gap: 2px; height: 10px; margin-top: 5px; }
        .life-pip { width: 15px; height: 8px; background: #333; border-radius: 2px; transition: background 0.2s; }
        .life-pip.active { background: #ff3b30; box-shadow: 0 0 10px #ff3b30; }
        
        .score-group { text-align: right; }
        .score-val { font-size: 36px; color: #fff; font-weight: 900; text-shadow: 0 0 15px #00e5ff; font-family: monospace; line-height: 1; }
        .score-label { font-size: 10px; color: #888; letter-spacing: 2px; text-transform: uppercase; }

        /* Combo ç‰¹æ•ˆ */
        .combo-container { 
            position: absolute; top: 25%; width: 100%; text-align: center; 
            opacity: 0; transition: opacity 0.1s; transform: scale(0.8);
        }
        .combo-num { font-size: 80px; font-weight: 900; color: #fff; -webkit-text-stroke: 2px #bd00ff; font-style: italic; line-height: 0.8; text-shadow: 5px 5px 0px rgba(0,0,0,0.5); }
        .combo-text { font-size: 20px; color: #bd00ff; letter-spacing: 5px; font-weight: bold; }
        
        /* åˆ¤å®šæ–‡å­— */
        .feedback { 
            position: absolute; font-size: 40px; font-weight: 900; z-index: 20; 
            white-space: nowrap; pointer-events: none; text-shadow: 0 2px 10px rgba(0,0,0,0.5);
            animation: floatUp 0.5s ease-out forwards;
        }
        @keyframes floatUp { to { transform: translate(-50%, -80px) scale(1.2); opacity: 0; } }
        
        .perfect { color: #ffd700; -webkit-text-stroke: 1px #fff; }
        .good { color: #00ffea; }
        .miss { color: #ff3b30; font-size: 50px; }

        /* === æŒ‰éˆ•èˆ‡é¸å–® === */
        .home-btn {
            position: absolute; top: 15px; left: 15px; pointer-events: auto; z-index: 200;
            text-decoration: none; font-size: 24px; color: #fff;
            width: 44px; height: 44px; background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3); border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(5px); transition: transform 0.1s;
        }
        .home-btn:active { transform: scale(0.9); background: rgba(255,255,255,0.3); }

        #start-screen { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(5, 5, 10, 0.95); backdrop-filter: blur(15px);
            display: flex; flex-direction: column; justify-content: center; align-items: center; 
            z-index: 100; transition: opacity 0.3s;
        }
        
        .logo { font-size: 42px; color: #fff; font-weight: 900; letter-spacing: -2px; text-shadow: 0 0 20px #00e5ff; margin-bottom: 5px; font-style: italic; }
        .tagline { color: #bd00ff; font-size: 14px; margin-bottom: 40px; letter-spacing: 3px; text-transform: uppercase; font-weight: bold; }

        .diff-btn {
            width: 260px; padding: 18px; margin: 8px 0;
            background: transparent; border: 2px solid #333; border-radius: 12px;
            color: #fff; font-size: 18px; font-weight: bold; letter-spacing: 1px;
            cursor: pointer; position: relative; overflow: hidden; transition: 0.2s;
            text-transform: uppercase; display: flex; justify-content: space-between; align-items: center;
        }
        .diff-btn span { pointer-events: none; }
        .diff-btn .dots { font-size: 12px; opacity: 0.5; }
        
        .diff-btn:active { transform: scale(0.95); }
        
        .d-easy { border-color: #00ff66; color: #00ff66; }
        .d-easy:hover { background: rgba(0,255,102,0.1); box-shadow: 0 0 20px rgba(0,255,102,0.3); }
        
        .d-normal { border-color: #00e5ff; color: #00e5ff; }
        .d-normal:hover { background: rgba(0,229,255,0.1); box-shadow: 0 0 20px rgba(0,229,255,0.3); }
        
        .d-hard { border-color: #ffcc00; color: #ffcc00; }
        .d-hard:hover { background: rgba(255,204,0,0.1); box-shadow: 0 0 20px rgba(255,204,0,0.3); }
        
        .d-insane { border-color: #ff0055; color: #ff0055; animation: pulseBorder 1s infinite alternate; }
        .d-insane:hover { background: rgba(255,0,85,0.1); box-shadow: 0 0 30px rgba(255,0,85,0.5); }
        @keyframes pulseBorder { from { box-shadow: 0 0 5px #ff0055; } to { box-shadow: 0 0 20px #ff0055; } }

        /* Game Over UI */
        #game-over-ui { display: none; flex-direction: column; align-items: center; width: 100%; }
        .final-score { font-size: 70px; font-weight: 900; color: #fff; margin: 10px 0 30px 0; text-shadow: 0 0 30px rgba(255,255,255,0.5); }
        .menu-btn { padding: 15px 40px; background: #fff; color: #000; border: none; font-size: 20px; font-weight: bold; border-radius: 50px; cursor: pointer; box-shadow: 0 0 20px #fff; }

    </style>
</head>
<body>

<a href="index.html" class="home-btn">ğŸ </a>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="danger-overlay"></div>

    <div id="ui-layer">
        <div class="hud">
            <div class="life-group">
                <div style="font-size: 12px; color: #888; font-weight: bold;">ENERGY</div>
                <div class="life-bar" id="life-container">
                    </div>
            </div>
            <div class="score-group">
                <div class="score-label">SCORE</div>
                <div class="score-val" id="score-val">0</div>
            </div>
        </div>

        <div class="combo-container" id="combo-box">
            <div class="combo-num" id="combo-val">0</div>
            <div class="combo-text">COMBO</div>
        </div>
    </div>

    <div id="start-screen">
        <div id="main-menu" style="display: flex; flex-direction: column; align-items: center; width: 100%;">
            <div class="logo">NEON PIANO</div>
            <div class="tagline">MAX VOLUME EDITION</div>
            
            <button class="diff-btn d-easy" onclick="startGame('EASY')">
                <span>EASY</span> <span class="dots">â—</span>
            </button>
            <button class="diff-btn d-normal" onclick="startGame('NORMAL')">
                <span>NORMAL</span> <span class="dots">â—â—</span>
            </button>
            <button class="diff-btn d-hard" onclick="startGame('HARD')">
                <span>HARD</span> <span class="dots">â—â—â—</span>
            </button>
            <button class="diff-btn d-insane" onclick="startGame('INSANE')">
                <span>INSANE</span> <span class="dots">â˜ ï¸â˜ ï¸â˜ ï¸</span>
            </button>
        </div>

        <div id="game-over-ui">
            <div style="color: #ff3b30; font-size: 30px; font-weight: 900; letter-spacing: 5px;">GAME OVER</div>
            <div class="final-score" id="final-score">0</div>
            <button class="menu-btn" onclick="resetToMenu()">MAIN MENU</button>
        </div>
    </div>
</div>

<script>
    /** ================= ç³»çµ±è¨­ç½® ================= **/
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const gameContainer = document.getElementById('game-container');
    const dangerOverlay = document.getElementById('danger-overlay');
    
    // UI Elements
    const uiLayer = document.getElementById('ui-layer');
    const scoreValEl = document.getElementById('score-val');
    const lifeContainer = document.getElementById('life-container');
    const comboBox = document.getElementById('combo-box');
    const comboValEl = document.getElementById('combo-val');
    
    // Screens
    const startScreen = document.getElementById('start-screen');
    const mainMenu = document.getElementById('main-menu');
    const gameOverUi = document.getElementById('game-over-ui');
    const finalScoreEl = document.getElementById('final-score');

    // éŠæˆ²ç‹€æ…‹
    let gameState = 'MENU';
    let score = 0;
    let combo = 0;
    let life = 10;
    const MAX_LIFE = 10;
    
    // å¯¦é«”
    let notes = [];
    let particles = [];
    let laneEffects = [0,0,0,0]; // è»Œé“å…‰æŸ±å¼·åº¦ 0~1
    
    // æ™‚é–“æ§åˆ¶
    let nextSpawnTime = 0;

    /** ================= é›£åº¦é…ç½® (ç¶“éå¯©æŸ¥å„ªåŒ–ï¼šæ–¹å¡Šæ›´å¤š) ================= **/
    const CONFIG = {
        LANE_COUNT: 4,
        HIT_Y_RATIO: 0.85,
        COLORS: ['#ff0055', '#00e5ff', '#ffcc00', '#00ff66'], // Neon Palette
        BASE_SPEED: 0.001
    };

    // å¯©æŸ¥ä¿®æ­£ï¼šå¤§å¹…ç¸®çŸ­ gapï¼Œä¸¦å¢åŠ å¤šæŠ¼æ©Ÿç‡
    const DIFFICULTIES = {
        'EASY':   { speedMod: 1.0, gap: 500,  multiChance: 0.0 }, // å·²ç¶“å¾ˆå¿«äº†
        'NORMAL': { speedMod: 1.4, gap: 400,  multiChance: 0.1 }, 
        'HARD':   { speedMod: 1.8, gap: 300,  multiChance: 0.3 }, // 30% æ©Ÿç‡é›™æŠ¼
        'INSANE': { speedMod: 2.5, gap: 180,  multiChance: 0.5 }  // 50% æ©Ÿç‡å¤šæŠ¼ï¼Œæ¥µé™å¯†åº¦
    };

    let currentDiffSetting = DIFFICULTIES['NORMAL'];
    let metrics = { w: 0, h: 0, laneW: 0, hitY: 0, speed: 0 };

    /** ================= æ ¸å¿ƒèˆ‡æ¸²æŸ“ ================= **/
    function resize() {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        
        metrics.w = rect.width;
        metrics.h = rect.height;
        metrics.laneW = metrics.w / CONFIG.LANE_COUNT;
        metrics.hitY = metrics.h * CONFIG.HIT_Y_RATIO;
        
        if (gameState === 'PLAYING') {
            metrics.speed = metrics.h * CONFIG.BASE_SPEED * currentDiffSetting.speedMod;
        }
    }
    window.addEventListener('resize', resize);
    resize();

    // ç¹ªè£½è¡€æ¢
    function renderLifeBar() {
        lifeContainer.innerHTML = '';
        for(let i=0; i<MAX_LIFE; i++) {
            const pip = document.createElement('div');
            pip.className = `life-pip ${i < life ? 'active' : ''}`;
            lifeContainer.appendChild(pip);
        }
        
        // ç€•æ­»è­¦å‘Š
        if (life <= 3 && life > 0) {
            dangerOverlay.classList.add('danger-active');
        } else {
            dangerOverlay.classList.remove('danger-active');
        }
    }

    /** ================= éŸ³æ•ˆç³»çµ± (MAX Volume) ================= **/
    let audioCtx;
    // ä½¿ç”¨æ›´è±å¯Œçš„å’Œå¼¦éŸ³éš
    const FREQS = [261.63, 311.13, 392.00, 523.25]; // Cm7
    
    function initAudio() {
        if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if(audioCtx.state === 'suspended') audioCtx.resume();
    }

    function playSound(lane, type) {
        if(!audioCtx) return;
        
        // 1. ä¸»éŸ³æº (Sawtooth for impact)
        const osc = audioCtx.createOscillator();
        osc.type = 'sawtooth';
        
        // Perfect éŸ³èª¿é«˜å…«åº¦
        let freq = FREQS[lane % 4];
        if (type === 'PERFECT') freq *= 2;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);

        // 2. å‰¯éŸ³æº (Sine for body - è®“è²éŸ³æ›´åšå¯¦)
        const subOsc = audioCtx.createOscillator();
        subOsc.type = 'sine';
        subOsc.frequency.setValueAtTime(freq / 2, audioCtx.currentTime); // ä½å…«åº¦

        // Gain Node (éŸ³é‡æ§åˆ¶)
        const gain = audioCtx.createGain();
        // â˜…â˜…â˜… å¯©æŸ¥é‡é»ï¼šéŸ³é‡å…¨é–‹ â˜…â˜…â˜…
        const maxVol = 0.8; // ç¸½åˆä¸è¦è¶…é 1.0 é¿å…çˆ†éŸ³
        gain.gain.setValueAtTime(maxVol, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);

        // é€£æ¥
        osc.connect(gain);
        subOsc.connect(gain);
        gain.connect(audioCtx.destination);

        osc.start();
        subOsc.start();
        osc.stop(audioCtx.currentTime + 0.3);
        subOsc.stop(audioCtx.currentTime + 0.3);
    }

    /** ================= éŠæˆ²é‚è¼¯ ================= **/
    function startGame(diff) {
        currentDiffSetting = DIFFICULTIES[diff];
        metrics.speed = metrics.h * CONFIG.BASE_SPEED * currentDiffSetting.speedMod;
        
        // é‡ç½®ç‹€æ…‹
        score = 0;
        combo = 0;
        life = MAX_LIFE;
        notes = [];
        particles = [];
        nextSpawnTime = Date.now();
        gameState = 'PLAYING';
        
        // UI æ›´æ–°
        scoreValEl.innerText = '0';
        renderLifeBar();
        startScreen.style.opacity = 0;
        setTimeout(() => startScreen.style.display = 'none', 300);
        
        initAudio();
        loop();
    }

    function spawnLogic(now) {
        if (now > nextSpawnTime) {
            // åŸºç¤é–“éš”
            let gap = currentDiffSetting.gap;
            // éš¨è‘— Combo åŠ é€Ÿ (æœ€é«˜å¿« 20%)
            gap *= (1 - Math.min(combo * 0.002, 0.2));

            // ç”Ÿæˆç¬¬ä¸€å€‹éŸ³ç¬¦
            const lane1 = Math.floor(Math.random() * 4);
            createNote(lane1, now);

            // â˜… å¤šæŠ¼æª¢å®š (Multi-Note Logic) â˜…
            if (Math.random() < currentDiffSetting.multiChance) {
                let lane2 = (lane1 + 1 + Math.floor(Math.random() * 3)) % 4; // ç¢ºä¿ä¸åŒè»Œé“
                createNote(lane2, now);
                
                // INSANE æ¨¡å¼æ¥µå°æ©Ÿç‡å‡ºç¾ä¸‰æŠ¼
                if (currentDiffSetting.multiChance > 0.4 && Math.random() < 0.3) {
                     let lane3 = (lane1 + 2) % 4;
                     if (lane3 !== lane2) createNote(lane3, now);
                }
            }
            
            nextSpawnTime = now + gap;
        }
    }

    function createNote(lane, time) {
        notes.push({
            lane: lane,
            y: -150, // å¾ç•«é¢å¤–ç”Ÿæˆ
            color: CONFIG.COLORS[lane],
            hit: false,
            missed: false
        });
    }

    function updatePhysics() {
        notes.forEach(n => {
            if (n.hit || n.missed) return;
            n.y += metrics.speed * 16; // *16 æ­£è¦åŒ– Delta Time

            // Miss åˆ¤å®š
            if (n.y > metrics.h) {
                n.missed = true;
                handleMiss(n.lane);
            }
        });
        
        // æ¸…ç†
        notes = notes.filter(n => !n.hit && !n.missed);
        
        // ç²’å­ç‰©ç†
        for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].x += particles[i].vx;
            particles[i].y += particles[i].vy;
            particles[i].life -= 0.02;
            if (particles[i].life <= 0) particles.splice(i, 1);
        }

        // å…‰æŸ±æ·¡å‡º
        for (let i=0; i<4; i++) {
            if (laneEffects[i] > 0) laneEffects[i] -= 0.1;
        }
    }

    function handleMiss(lane) {
        life--;
        combo = 0;
        renderLifeBar();
        updateComboUI();
        
        // ç•«é¢éœ‡å‹•ç‰¹æ•ˆ
        gameContainer.style.transform = `translate(${Math.random()*10-5}px, ${Math.random()*10-5}px)`;
        setTimeout(() => gameContainer.style.transform = 'none', 50);

        showFeedback(lane * metrics.laneW + metrics.laneW/2, metrics.h - 50, 'MISS', 'miss');

        if (life <= 0) gameOver();
    }

    function handleHit(lane) {
        if (gameState !== 'PLAYING') return;

        // è¦–è¦ºå›é¥‹ï¼šè»Œé“äº®èµ·
        laneEffects[lane] = 1.0;

        // åˆ¤å®šé‚è¼¯
        const hitZone = 150; // å¯¬å®¹åº¦
        const target = notes.find(n => n.lane === lane && !n.hit && Math.abs(n.y - metrics.hitY) < hitZone);
        
        if (target) {
            target.hit = true;
            const dist = Math.abs(target.y - metrics.hitY);
            const x = lane * metrics.laneW + metrics.laneW/2;
            const y = metrics.hitY;

            if (dist < 50) {
                // Perfect
                score += 100;
                combo++;
                playSound(lane, 'PERFECT');
                showFeedback(x, y, 'PERFECT', 'perfect');
                spawnParticles(x, y, target.color, 15);
            } else {
                // Good
                score += 50;
                combo++;
                playSound(lane, 'GOOD');
                showFeedback(x, y, 'GOOD', 'good');
                spawnParticles(x, y, '#fff', 8);
            }
            scoreValEl.innerText = score;
            updateComboUI();
        }
    }

    function spawnParticles(x, y, color, count) {
        for(let i=0; i<count; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                color: color,
                life: 1.0,
                size: Math.random() * 5 + 2
            });
        }
    }

    function showFeedback(x, y, text, type) {
        const el = document.createElement('div');
        el.className = `feedback ${type}`;
        el.innerText = text;
        // éš¨æ©Ÿæ—‹è½‰ä¸€é»é»
        const rot = (Math.random() - 0.5) * 20;
        el.style.left = x + 'px';
        el.style.top = y + 'px';
        el.style.transform = `translate(-50%, -50%) rotate(${rot}deg)`;
        
        uiLayer.appendChild(el);
        setTimeout(() => el.remove(), 500);
    }

    function updateComboUI() {
        if (combo > 5) {
            comboBox.style.opacity = 1;
            comboBox.style.transform = 'scale(1.2)';
            comboValEl.innerText = combo;
            setTimeout(() => comboBox.style.transform = 'scale(1)', 100);
        } else {
            comboBox.style.opacity = 0;
            comboBox.style.transform = 'scale(0.8)';
        }
    }

    function gameOver() {
        gameState = 'GAMEOVER';
        finalScoreEl.innerText = score;
        
        startScreen.style.display = 'flex';
        mainMenu.style.display = 'none';
        gameOverUi.style.display = 'flex';
        
        setTimeout(() => startScreen.style.opacity = 1, 10);
        dangerOverlay.classList.remove('danger-active');
    }

    function resetToMenu() {
        mainMenu.style.display = 'flex';
        gameOverUi.style.display = 'none';
        gameState = 'MENU';
    }

    /** ================= è¼¸å…¥ç›£è½ ================= **/
    const keys = ['d', 'f', 'j', 'k'];
    
    document.addEventListener('keydown', e => {
        if (e.repeat) return;
        const idx = keys.indexOf(e.key.toLowerCase());
        if (idx > -1) handleHit(idx);
    });

    canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        for (let i = 0; i < e.touches.length; i++) {
            const touch = e.touches[i];
            const lane = Math.floor((touch.clientX / metrics.w) * 4);
            if (lane >= 0 && lane < 4) handleHit(lane);
        }
    }, { passive: false });

    /** ================= éŠæˆ²å¾ªç’° ================= **/
    function loop() {
        if (gameState !== 'PLAYING') return;

        ctx.clearRect(0, 0, metrics.w, metrics.h);
        
        const now = Date.now();
        spawnLogic(now);
        updatePhysics();

        // 1. ç¹ªè£½è»Œé“å…‰æŸ (Additive Blending)
        ctx.globalCompositeOperation = 'lighter';
        for(let i=0; i<4; i++) {
            if(laneEffects[i] > 0) {
                const alpha = laneEffects[i];
                const grd = ctx.createLinearGradient(0, 0, 0, metrics.h);
                grd.addColorStop(0, CONFIG.COLORS[i]);
                grd.addColorStop(1, 'transparent');
                ctx.fillStyle = grd;
                ctx.globalAlpha = alpha * 0.4;
                ctx.fillRect(i * metrics.laneW, 0, metrics.laneW, metrics.h);
            }
        }
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1;

        // 2. è»Œé“åˆ†éš”ç·š
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for(let i=1; i<4; i++) {
            ctx.moveTo(i*metrics.laneW, 0);
            ctx.lineTo(i*metrics.laneW, metrics.h);
        }
        ctx.stroke();

        // 3. åˆ¤å®šç·š (ç™¼å…‰)
        ctx.shadowBlur = 15; ctx.shadowColor = '#00e5ff';
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, metrics.hitY); ctx.lineTo(metrics.w, metrics.hitY);
        ctx.stroke();
        ctx.shadowBlur = 0;

        // 4. éŸ³ç¬¦
        notes.forEach(n => {
            if (n.hit) return;
            
            // éœ“è™¹å…‰æšˆ
            ctx.shadowBlur = 20; ctx.shadowColor = n.color;
            ctx.fillStyle = n.color;
            
            // æ–¹å¡Šä¸»é«”
            const pad = 4;
            const w = metrics.laneW - pad*2;
            const h = metrics.h * 0.12;
            ctx.fillRect(n.lane * metrics.laneW + pad, n.y, w, h);
            
            // é«˜å…‰æ¢ (ç«‹é«”æ„Ÿ)
            ctx.fillStyle = 'rgba(255,255,255,0.8)';
            ctx.fillRect(n.lane * metrics.laneW + pad, n.y, w, 10);
            
            ctx.shadowBlur = 0;
        });

        // 5. ç²’å­
        particles.forEach(p => {
            p.draw(ctx);
        });

        requestAnimationFrame(loop);
    }
</script>
</body>
</html>
