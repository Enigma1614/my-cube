<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Piano | Êô∫ÊÖßËß∏ÊéßÁâà</title>
    <style>
        /* === Ê†∏ÂøÉÊ®£ÂºèÔºöÈéñÊ≠ªËß∏ÊéßÔºåÈò≤Ê≠¢Á∏ÆÊîæ === */
        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            background: #000; overflow: hidden; 
            font-family: 'Segoe UI', 'Roboto', sans-serif; 
            touch-action: none; user-select: none; -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent; /* ÁßªÈô§ÈªûÊìäÈ´ò‰∫Æ */
        }
        
        #game-container { 
            position: relative; width: 100%; height: 100%; max-width: 650px; margin: 0 auto; 
            background: linear-gradient(to bottom, #120526 0%, #000 100%);
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.1); 
            transition: transform 0.05s;
        }
        
        canvas { display: block; width: 100%; height: 100%; }

        /* === ÁÄïÊ≠ªÁ¥ÖÊ°ÜË≠¶ÂëäÁâπÊïà === */
        #danger-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            box-shadow: inset 0 0 100px rgba(255, 0, 0, 0);
            pointer-events: none; z-index: 5;
            transition: box-shadow 0.3s;
        }
        .danger-active { animation: dangerPulse 0.8s infinite; }
        @keyframes dangerPulse { 
            0%, 100% { box-shadow: inset 0 0 50px rgba(255, 0, 0, 0.3); } 
            50% { box-shadow: inset 0 0 150px rgba(255, 0, 0, 0.8); } 
        }
        
        /* === UI Â±§ === */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; }
        
        /* È†ÇÈÉ®Ë≥áË®äÂàó */
        .hud { 
            width: 100%; padding: 60px 20px 10px 20px; 
            display: flex; justify-content: space-between; align-items: flex-end; 
            box-sizing: border-box; z-index: 10;
        }

        .life-group { text-align: left; }
        .life-bar { display: flex; gap: 2px; height: 10px; margin-top: 5px; }
        .life-pip { width: 15px; height: 8px; background: #333; border-radius: 2px; transition: background 0.2s; }
        .life-pip.active { background: #ff3b30; box-shadow: 0 0 10px #ff3b30; }
        
        .score-group { text-align: right; }
        .score-val { font-size: 36px; color: #fff; font-weight: 900; text-shadow: 0 0 15px #00e5ff; font-family: monospace; line-height: 1; }
        .score-label { font-size: 10px; color: #888; letter-spacing: 2px; text-transform: uppercase; }

        /* Combo ÁâπÊïà */
        .combo-container { 
            position: absolute; top: 25%; width: 100%; text-align: center; 
            opacity: 0; transition: opacity 0.1s; transform: scale(0.8);
        }
        .combo-num { font-size: 80px; font-weight: 900; color: #fff; -webkit-text-stroke: 2px #bd00ff; font-style: italic; line-height: 0.8; text-shadow: 5px 5px 0px rgba(0,0,0,0.5); }
        .combo-text { font-size: 20px; color: #bd00ff; letter-spacing: 5px; font-weight: bold; }
        
        /* Âà§ÂÆöÊñáÂ≠ó */
        .feedback { 
            position: absolute; font-size: 40px; font-weight: 900; z-index: 20; 
            white-space: nowrap; pointer-events: none; text-shadow: 0 2px 10px rgba(0,0,0,0.5);
            animation: floatUp 0.5s ease-out forwards;
        }
        @keyframes floatUp { to { transform: translate(-50%, -80px) scale(1.2); opacity: 0; } }
        
        .perfect { color: #ffd700; -webkit-text-stroke: 1px #fff; }
        .good { color: #00ffea; }
        .miss { color: #ff3b30; font-size: 50px; }

        /* === ÊåâÈàïËàáÈÅ∏ÂñÆ === */
        .home-btn {
            position: absolute; top: 15px; left: 15px; pointer-events: auto; z-index: 200;
            text-decoration: none; font-size: 24px; color: #fff;
            width: 44px; height: 44px; background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3); border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(5px); transition: transform 0.1s;
        }
        .home-btn:active { transform: scale(0.9); background: rgba(255,255,255,0.3); }

        #start-screen { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(5, 5, 10, 0.95); backdrop-filter: blur(15px);
            display: flex; flex-direction: column; justify-content: center; align-items: center; 
            z-index: 100; transition: opacity 0.3s;
        }
        
        .logo { font-size: 42px; color: #fff; font-weight: 900; letter-spacing: -2px; text-shadow: 0 0 20px #00e5ff; margin-bottom: 5px; font-style: italic; }
        .tagline { color: #bd00ff; font-size: 14px; margin-bottom: 40px; letter-spacing: 3px; text-transform: uppercase; font-weight: bold; }

        .diff-btn {
            width: 260px; padding: 18px; margin: 8px 0;
            background: transparent; border: 2px solid #333; border-radius: 12px;
            color: #fff; font-size: 18px; font-weight: bold; letter-spacing: 1px;
            cursor: pointer; position: relative; overflow: hidden; transition: 0.2s;
            text-transform: uppercase; display: flex; justify-content: space-between; align-items: center;
        }
        .diff-btn span { pointer-events: none; }
        .diff-btn .dots { font-size: 12px; opacity: 0.5; }
        
        .diff-btn:active { transform: scale(0.95); }
        
        .d-easy { border-color: #00ff66; color: #00ff66; }
        .d-easy:hover { background: rgba(0,255,102,0.1); box-shadow: 0 0 20px rgba(0,255,102,0.3); }
        
        .d-normal { border-color: #00e5ff; color: #00e5ff; }
        .d-normal:hover { background: rgba(0,229,255,0.1); box-shadow: 0 0 20px rgba(0,229,255,0.3); }
        
        .d-hard { border-color: #ffcc00; color: #ffcc00; }
        .d-hard:hover { background: rgba(255,204,0,0.1); box-shadow: 0 0 20px rgba(255,204,0,0.3); }
        
        .d-insane { border-color: #ff0055; color: #ff0055; animation: pulseBorder 1s infinite alternate; }
        .d-insane:hover { background: rgba(255,0,85,0.1); box-shadow: 0 0 30px rgba(255,0,85,0.5); }
        @keyframes pulseBorder { from { box-shadow: 0 0 5px #ff0055; } to { box-shadow: 0 0 20px #ff0055; } }

        /* Game Over UI */
        #game-over-ui { display: none; flex-direction: column; align-items: center; width: 100%; }
        .final-score { font-size: 70px; font-weight: 900; color: #fff; margin: 10px 0 30px 0; text-shadow: 0 0 30px rgba(255,255,255,0.5); }
        .menu-btn { padding: 15px 40px; background: #fff; color: #000; border: none; font-size: 20px; font-weight: bold; border-radius: 50px; cursor: pointer; box-shadow: 0 0 20px #fff; }

    </style>
</head>
<body>

<a href="index.html" class="home-btn">üè†</a>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="danger-overlay"></div>

    <div id="ui-layer">
        <div class="hud">
            <div class="life-group">
                <div style="font-size: 12px; color: #888; font-weight: bold;">ENERGY</div>
                <div class="life-bar" id="life-container"></div>
            </div>
            <div class="score-group">
                <div class="score-label">SCORE</div>
                <div class="score-val" id="score-val">0</div>
            </div>
        </div>

        <div class="combo-container" id="combo-box">
            <div class="combo-num" id="combo-val">0</div>
            <div class="combo-text">COMBO</div>
        </div>
    </div>

    <div id="start-screen">
        <div id="main-menu" style="display: flex; flex-direction: column; align-items: center; width: 100%;">
            <div class="logo">NEON PIANO</div>
            <div class="tagline">SMART TOUCH EDITION</div>
            
            <button class="diff-btn d-easy" onclick="startGame('EASY')">
                <span>EASY</span> <span class="dots">‚óè</span>
            </button>
            <button class="diff-btn d-normal" onclick="startGame('NORMAL')">
                <span>NORMAL</span> <span class="dots">‚óè‚óè</span>
            </button>
            <button class="diff-btn d-hard" onclick="startGame('HARD')">
                <span>HARD</span> <span class="dots">‚óè‚óè‚óè</span>
            </button>
            <button class="diff-btn d-insane" onclick="startGame('INSANE')">
                <span>INSANE</span> <span class="dots">‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è</span>
            </button>
        </div>

        <div id="game-over-ui">
            <div style="color: #ff3b30; font-size: 30px; font-weight: 900; letter-spacing: 5px;">GAME OVER</div>
            <div class="final-score" id="final-score">0</div>
            <button class="menu-btn" onclick="resetToMenu()">MAIN MENU</button>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const gameContainer = document.getElementById('game-container');
    const dangerOverlay = document.getElementById('danger-overlay');
    
    const uiLayer = document.getElementById('ui-layer');
    const scoreValEl = document.getElementById('score-val');
    const lifeContainer = document.getElementById('life-container');
    const comboBox = document.getElementById('combo-box');
    const comboValEl = document.getElementById('combo-val');
    
    const startScreen = document.getElementById('start-screen');
    const mainMenu = document.getElementById('main-menu');
    const gameOverUi = document.getElementById('game-over-ui');
    const finalScoreEl = document.getElementById('final-score');

    let gameState = 'MENU';
    let score = 0;
    let combo = 0;
    let life = 10;
    const MAX_LIFE = 10;
    
    let notes = [];
    let particles = [];
    let laneEffects = [0,0,0,0]; 
    let nextSpawnTime = 0;

    class Particle {
        constructor(x, y, color) {
            this.x = x; this.y = y; this.color = color;
            this.vx = (Math.random() - 0.5) * 12;
            this.vy = (Math.random() - 0.5) * 12;
            this.life = 1.0;
            this.size = Math.random() * 5 + 3;
            this.decay = Math.random() * 0.03 + 0.02;
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += 0.5;
            this.life -= this.decay;
        }
        draw(ctx) {
            ctx.globalAlpha = Math.max(0, this.life);
            ctx.fillStyle = this.color;
            ctx.beginPath(); 
            ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); 
            ctx.fill();
            ctx.globalAlpha = 1;
        }
    }

    const CONFIG = {
        LANE_COUNT: 4,
        HIT_Y_RATIO: 0.85,
        COLORS: ['#ff0055', '#00e5ff', '#ffcc00', '#00ff66'], 
        BASE_SPEED: 0.001
    };

    const DIFFICULTIES = {
        'EASY':   { speedMod: 1.0, gap: 500,  multiChance: 0.0 }, 
        'NORMAL': { speedMod: 1.4, gap: 400,  multiChance: 0.1 }, 
        'HARD':   { speedMod: 1.8, gap: 300,  multiChance: 0.3 }, 
        'INSANE': { speedMod: 2.5, gap: 180,  multiChance: 0.5 }
    };

    let currentDiffSetting = DIFFICULTIES['NORMAL'];
    let metrics = { w: 0, h: 0, laneW: 0, hitY: 0, speed: 0 };

    function resize() {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        
        metrics.w = rect.width;
        metrics.h = rect.height;
        metrics.laneW = metrics.w / CONFIG.LANE_COUNT;
        metrics.hitY = metrics.h * CONFIG.HIT_Y_RATIO;
        
        if (gameState === 'PLAYING') {
            metrics.speed = metrics.h * CONFIG.BASE_SPEED * currentDiffSetting.speedMod;
        }
    }
    window.addEventListener('resize', resize);
    resize();

    function renderLifeBar() {
        lifeContainer.innerHTML = '';
        for(let i=0; i<MAX_LIFE; i++) {
            const pip = document.createElement('div');
            pip.className = `life-pip ${i < life ? 'active' : ''}`;
            lifeContainer.appendChild(pip);
        }
        if (life <= 3 && life > 0) {
            dangerOverlay.classList.add('danger-active');
        } else {
            dangerOverlay.classList.remove('danger-active');
        }
    }

    let audioCtx;
    const FREQS = [261.63, 311.13, 392.00, 523.25];
    
    function initAudio() {
        if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if(audioCtx.state === 'suspended') audioCtx.resume();
    }

    function playSound(lane, type) {
        if(!audioCtx) return;
        const osc = audioCtx.createOscillator();
        osc.type = 'sawtooth';
        let freq = FREQS[lane % 4];
        if (type === 'PERFECT') freq *= 2;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        const subOsc = audioCtx.createOscillator();
        subOsc.type = 'sine';
        subOsc.frequency.setValueAtTime(freq / 2, audioCtx.currentTime);
        const gain = audioCtx.createGain();
        const maxVol = 0.8; 
        gain.gain.setValueAtTime(maxVol, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
        osc.connect(gain);
        subOsc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        subOsc.start();
        osc.stop(audioCtx.currentTime + 0.3);
        subOsc.stop(audioCtx.currentTime + 0.3);
    }

    function startGame(diff) {
        currentDiffSetting = DIFFICULTIES[diff];
        metrics.speed = metrics.h * CONFIG.BASE_SPEED * currentDiffSetting.speedMod;
        score = 0;
        combo = 0;
        life = MAX_LIFE;
        notes = [];
        particles = [];
        nextSpawnTime = Date.now();
        gameState = 'PLAYING';
        scoreValEl.innerText = '0';
        renderLifeBar();
        startScreen.style.opacity = 0;
        setTimeout(() => startScreen.style.display = 'none', 300);
        initAudio();
        loop();
    }

    function spawnLogic(now) {
        if (now > nextSpawnTime) {
            let gap = currentDiffSetting.gap;
            gap *= (1 - Math.min(combo * 0.002, 0.2));
            const lane1 = Math.floor(Math.random() * 4);
            createNote(lane1, now);
            if (Math.random() < currentDiffSetting.multiChance) {
                let lane2 = (lane1 + 1 + Math.floor(Math.random() * 3)) % 4;
                createNote(lane2, now);
                if (currentDiffSetting.multiChance > 0.4 && Math.random() < 0.3) {
                     let lane3 = (lane1 + 2) % 4;
                     if (lane3 !== lane2) createNote(lane3, now);
                }
            }
            nextSpawnTime = now + gap;
        }
    }

    function createNote(lane, time) {
        notes.push({
            lane: lane,
            y: -150,
            color: CONFIG.COLORS[lane],
            hit: false,
            missed: false
        });
    }

    function updatePhysics() {
        notes.forEach(n => {
            if (n.hit || n.missed) return;
            n.y += metrics.speed * 16; 
            if (n.y > metrics.h) {
                n.missed = true;
                handleMiss(n.lane);
            }
        });
        notes = notes.filter(n => !n.hit && !n.missed);
        for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update();
            if (particles[i].life <= 0) particles.splice(i, 1);
        }
        for (let i=0; i<4; i++) {
            if (laneEffects[i] > 0) laneEffects[i] -= 0.1;
        }
    }

    function handleMiss(lane) {
        life--;
        combo = 0;
        renderLifeBar();
        updateComboUI();
        gameContainer.style.transform = `translate(${Math.random()*10-5}px, ${Math.random()*10-5}px)`;
        setTimeout(() => gameContainer.style.transform = 'none', 50);
        showFeedback(lane * metrics.laneW + metrics.laneW/2, metrics.h - 50, 'MISS', 'miss');
        if (life <= 0) gameOver();
    }

    // ‚òÖ‚òÖ‚òÖ Êô∫ÊÖßËß∏ÊéßÂà§ÂÆöÊ†∏ÂøÉ (Smart Hit Logic) ‚òÖ‚òÖ‚òÖ
    // ËøîÂõû true Ë°®Á§∫ÊàêÂäüÂà§ÂÆöÔºåfalse Ë°®Á§∫Ë©≤ËªåÈÅìÊ≤íÊù±Ë•ø
    function attemptHit(lane) {
        // 1. ÂØ¨ÂÆπÂà§ÂÆöÂçÄÔºö180px (ÂûÇÁõ¥)
        const hitZone = 180; 
        
        // 2. Â∞ãÊâæÁõÆÊ®ô
        const target = notes.find(n => n.lane === lane && !n.hit && Math.abs(n.y - metrics.hitY) < hitZone);
        
        if (target) {
            target.hit = true;
            laneEffects[lane] = 1.0; // Ë¶ñË¶∫‰∫ÆËµ∑

            const dist = Math.abs(target.y - metrics.hitY);
            const x = lane * metrics.laneW + metrics.laneW/2;
            const y = metrics.hitY;

            if (dist < 60) { // ÊîæÂØ¨ Perfect Âà§ÂÆö
                score += 100;
                combo++;
                playSound(lane, 'PERFECT');
                showFeedback(x, y, 'PERFECT', 'perfect');
                spawnParticles(x, y, target.color, 15);
            } else {
                score += 50;
                combo++;
                playSound(lane, 'GOOD');
                showFeedback(x, y, 'GOOD', 'good');
                spawnParticles(x, y, '#fff', 8);
            }
            scoreValEl.innerText = score;
            updateComboUI();
            return true; // ÊàêÂäüÊìä‰∏≠
        }
        return false; // Ê≤íÊìä‰∏≠
    }

    // ËôïÁêÜËº∏ÂÖ•ÔºöÂåÖÂê´„ÄåÂÆπÈåØÊ©üÂà∂„Äç
    function processInput(lane, exactX = null) {
        if (gameState !== 'PLAYING') return;
        
        initAudio(); // Á¢∫‰øùÈü≥ÊïàÂïüÂãï

        // 1. ÂòóË©¶Áõ¥Êé•Âà§ÂÆöÈªûÊìäÁöÑËªåÈÅì
        if (attemptHit(lane)) return;

        // 2. Â¶ÇÊûú‰∏ªË¶ÅËªåÈÅìÊ≤íÊù±Ë•øÔºåÊ™¢Êü•ÊòØÂê¶ÈªûÂú®ÈÇäÁïå (Fat Finger Assist)
        if (exactX !== null) {
            const laneW = metrics.laneW;
            const localX = exactX % laneW; // Âú®Ë©≤ËªåÈÅìÂÖßÁöÑ X Â∫ßÊ®ô (0 ~ laneW)
            
            // Â¶ÇÊûúÈªûÊìä‰ΩçÁΩÆÈù†Â∑¶ÈÇäÁïå (< 35%)ÔºåÂòóË©¶Âà§ÂÆöÂ∑¶ÈÇäÁöÑËªåÈÅì
            if (localX < laneW * 0.35 && lane > 0) {
                if (attemptHit(lane - 1)) return;
            }
            // Â¶ÇÊûúÈªûÊìä‰ΩçÁΩÆÈù†Âè≥ÈÇäÁïå (> 65%)ÔºåÂòóË©¶Âà§ÂÆöÂè≥ÈÇäÁöÑËªåÈÅì
            else if (localX > laneW * 0.65 && lane < 3) {
                if (attemptHit(lane + 1)) return;
            }
        }

        // 3. Â¶ÇÊûúÈÉΩÊ≤íÂà§ÂÆöÂà∞ÔºåÂ∞±Áï∂‰ΩúÁ©∫ÊèÆ (Âè™‰∫ÆÁáà‰∏çË®àÂàÜÔºåÊàñÊí≠ÊîæÁ©∫ÊèÆÈü≥Êïà)
        laneEffects[lane] = 0.5; // Á®çÂæÆ‰∫Æ‰∏Ä‰∏ãË°®Á§∫ÊúâÊÑüÊáâÂà∞
    }

    function spawnParticles(x, y, color, count) {
        for(let i=0; i<count; i++) {
            particles.push(new Particle(x, y, color));
        }
    }

    function showFeedback(x, y, text, type) {
        const el = document.createElement('div');
        el.className = `feedback ${type}`;
        el.innerText = text;
        const rot = (Math.random() - 0.5) * 20;
        el.style.left = x + 'px';
        el.style.top = y + 'px';
        el.style.transform = `translate(-50%, -50%) rotate(${rot}deg)`;
        uiLayer.appendChild(el);
        setTimeout(() => el.remove(), 500);
    }

    function updateComboUI() {
        if (combo > 5) {
            comboBox.style.opacity = 1;
            comboBox.style.transform = 'scale(1.2)';
            comboValEl.innerText = combo;
            setTimeout(() => comboBox.style.transform = 'scale(1)', 100);
        } else {
            comboBox.style.opacity = 0;
            comboBox.style.transform = 'scale(0.8)';
        }
    }

    function gameOver() {
        gameState = 'GAMEOVER';
        finalScoreEl.innerText = score;
        startScreen.style.display = 'flex';
        mainMenu.style.display = 'none';
        gameOverUi.style.display = 'flex';
        setTimeout(() => startScreen.style.opacity = 1, 10);
        dangerOverlay.classList.remove('danger-active');
    }

    function resetToMenu() {
        mainMenu.style.display = 'flex';
        gameOverUi.style.display = 'none';
        gameState = 'MENU';
    }

    // --- Ëº∏ÂÖ•Áõ£ËÅΩ (ÊîπËâØÁâà) ---
    const keys = ['d', 'f', 'j', 'k'];
    document.addEventListener('keydown', e => {
        if (e.repeat) return;
        const idx = keys.indexOf(e.key.toLowerCase());
        if (idx > -1) processInput(idx);
    });

    // ÊîπÁõ£ËÅΩ bodyÔºåÁ¢∫‰øùÂÖ®Ëû¢ÂπïËß∏ÊéßÈÉΩÊúâÊïà
    document.body.addEventListener('touchstart', e => {
        // e.preventDefault(); // Ë®ªËß£ÊéâÔºöÊúâ‰∫õÁÄèË¶ΩÂô®ÈòªÊìãÈÄôÂÄãÊúÉÂ∞éËá¥Èü≥ÊïàÁÑ°Ê≥ïÂïüÂãïÔºåÈù†CSS touch-action: none Âç≥ÂèØ
        for (let i = 0; i < e.touches.length; i++) {
            const touch = e.touches[i];
            // Áç≤ÂèñÁõ∏Â∞çÊñº Canvas ÁöÑÂ∫ßÊ®ô
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            
            const lane = Math.floor((x / metrics.w) * 4);
            if (lane >= 0 && lane < 4) {
                processInput(lane, x);
            }
        }
    }, { passive: false });

    function loop() {
        if (gameState !== 'PLAYING') return;

        ctx.clearRect(0, 0, metrics.w, metrics.h);
        const now = Date.now();
        spawnLogic(now);
        updatePhysics();

        ctx.globalCompositeOperation = 'lighter';
        for(let i=0; i<4; i++) {
            if(laneEffects[i] > 0) {
                const alpha = laneEffects[i];
                const grd = ctx.createLinearGradient(0, 0, 0, metrics.h);
                grd.addColorStop(0, CONFIG.COLORS[i]);
                grd.addColorStop(1, 'transparent');
                ctx.fillStyle = grd;
                ctx.globalAlpha = alpha * 0.4;
                ctx.fillRect(i * metrics.laneW, 0, metrics.laneW, metrics.h);
            }
        }
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1;

        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for(let i=1; i<4; i++) {
            ctx.moveTo(i*metrics.laneW, 0);
            ctx.lineTo(i*metrics.laneW, metrics.h);
        }
        ctx.stroke();

        ctx.shadowBlur = 15; ctx.shadowColor = '#00e5ff';
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, metrics.hitY); ctx.lineTo(metrics.w, metrics.hitY);
        ctx.stroke();
        ctx.shadowBlur = 0;

        notes.forEach(n => {
            if (n.hit) return;
            ctx.shadowBlur = 20; ctx.shadowColor = n.color;
            ctx.fillStyle = n.color;
            const pad = 4;
            const w = metrics.laneW - pad*2;
            const h = metrics.h * 0.12;
            ctx.fillRect(n.lane * metrics.laneW + pad, n.y, w, h);
            ctx.fillStyle = 'rgba(255,255,255,0.8)';
            ctx.fillRect(n.lane * metrics.laneW + pad, n.y, w, 10);
            ctx.shadowBlur = 0;
        });

        particles.forEach(p => { p.draw(ctx); });

        requestAnimationFrame(loop);
    }
</script>
</body>
</html>
