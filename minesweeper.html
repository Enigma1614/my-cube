<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ¥µé™è¸©åœ°é›·</title>
    <style>
        :root { --bg: #050510; --accent: #00d2ff; --cell-bg: #1a1a2e; --cell-hover: #262642; }
        body {
            background: var(--bg); color: white; margin: 0; 
            font-family: system-ui, -apple-system, sans-serif;
            display: flex; flex-direction: column; align-items: center;
            height: 100vh; overflow: hidden; user-select: none;
            touch-action: manipulation;
        }

        /* === 1. ä¸Šæ–¹è³‡è¨Šå€ === */
        header {
            width: 100%; padding: 10px 15px; box-sizing: border-box;
            background: rgba(0,0,0,0.3); border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex; justify-content: space-between; align-items: center;
            flex-shrink: 0; z-index: 10; height: 60px;
        }
        .header-left { display: flex; align-items: center; gap: 12px; }
        .home-btn {
            text-decoration: none; font-size: 18px; color: #fff;
            background: rgba(255,255,255,0.1); width: 36px; height: 36px;
            display: flex; align-items: center; justify-content: center;
            border-radius: 8px; border: 1px solid rgba(255,255,255,0.2);
        }
        .home-btn:active { background: var(--accent); color: #000; }
        .game-title { font-weight: 800; letter-spacing: 1px; color: #fff; }
        .mine-count { font-family: monospace; font-size: 20px; color: #f1c40f; font-weight: bold; }

        /* === 2. éŠæˆ²ä¸»é«” === */
        #game-wrapper {
            flex: 1; width: 100%;
            display: flex; flex-direction: column; 
            align-items: center; justify-content: center;
            overflow: hidden; position: relative;
        }

        #status-msg {
            font-size: 24px; font-weight: 900; color: #fff; 
            text-shadow: 0 0 10px var(--accent);
            margin-bottom: 5px; height: 30px; line-height: 30px;
        }

        #grid-container {
            overflow: auto; 
            padding: 10px;
            /* è®“å®¹å™¨è‡ªé©æ‡‰å…§å®¹ï¼Œä½†æœ€å¤§ä¸è¶…éè¢å¹• */
            max-width: 98%; max-height: 98%;
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            background: rgba(0,0,0,0.2);
            /* å·è»¸ç¾åŒ– */
            scrollbar-width: thin; scrollbar-color: var(--accent) #333;
        }

        #grid {
            display: grid; gap: 2px;
            background: #333;
            pointer-events: auto;
            margin: auto; /* è®“æ ¼å­åœ¨å®¹å™¨å…§ç½®ä¸­ */
        }

        .cell {
            width: 35px; height: 35px;
            background: var(--cell-bg);
            display: flex; justify-content: center; align-items: center;
            font-weight: bold; font-size: 20px; cursor: pointer;
            transition: background 0.1s;
        }
        
        .cell.closed:active { background: var(--cell-hover); }
        .cell.open { background: #0b0b15; box-shadow: inset 0 0 5px rgba(0,0,0,0.5); }
        
        .cell.boom { background: #ff0055 !important; animation: shake 0.5s; border: 1px solid #fff; z-index: 2; }
        .cell.revealed-mine { background: #2a0a1a; opacity: 0.9; border: 1px solid #ff4444; }
        .cell.correct-flag { background: #0a2a0a; border: 1px solid #0f0; }
        .cell.wrong-flag { background: #2a0a0a; color: red; }

        .c-1 { color: #4cc9f0; } .c-2 { color: #4eff4e; } .c-3 { color: #ff4d6d; }
        .c-4 { color: #9d4edd; } .c-5 { color: #ff9e00; } .c-6 { color: #00ffff; }
        .c-7 { color: #fff; } .c-8 { color: #777; }

        /* === 3. ä¸‹æ–¹æ§åˆ¶å€ === */
        footer {
            width: 100%; padding: 10px;
            background: rgba(0,0,0,0.2);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            flex-shrink: 0; min-height: 100px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        /* æ¨¡å¼é¸æ“‡å€ (é–‹å§‹æ™‚é¡¯ç¤º) */
        #mode-selector {
            display: flex; gap: 10px;
        }
        
        /* é‡æ–°é–‹å§‹æŒ‰éˆ• (çµæŸæ™‚é¡¯ç¤º) */
        #restart-area {
            display: none; text-align: center;
        }

        button {
            padding: 10px 20px; font-size: 16px; font-weight: bold;
            border: none; border-radius: 8px; cursor: pointer; color: #000;
            transition: transform 0.1s, filter 0.2s;
            min-width: 80px;
        }
        button:active { transform: scale(0.95); }

        .btn-easy { background: #4eff4e; box-shadow: 0 0 10px #4eff4e; }
        .btn-normal { background: #4cc9f0; box-shadow: 0 0 10px #4cc9f0; }
        .btn-hard { background: #ff4d6d; box-shadow: 0 0 10px #ff4d6d; }
        .btn-restart { 
            background: #f1c40f; box-shadow: 0 0 15px #f1c40f; 
            padding: 12px 40px; font-size: 20px; border-radius: 50px;
        }

        .hint { color: #888; font-size: 12px; margin-top: 8px; text-align: center; }

        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }
    </style>
</head>
<body>

    <header>
        <div class="header-left">
            <a href="index.html" class="home-btn">ğŸ </a>
            <div class="game-title">MINESWEEPER</div>
        </div>
        <div class="mine-count">ğŸ’£ <span id="mineCount">--</span></div>
    </header>

    <div id="game-wrapper">
        <div id="status-msg">è«‹é¸æ“‡é›£åº¦</div>
        <div id="grid-container">
            <div id="grid"></div>
        </div>
    </div>

    <footer>
        <div id="mode-selector">
            <button class="btn-easy" onclick="startGame('easy')">ç°¡å–®</button>
            <button class="btn-normal" onclick="startGame('normal')">æ™®é€š</button>
            <button class="btn-hard" onclick="startGame('hard')">å›°é›£</button>
        </div>

        <div id="restart-area">
            <button class="btn-restart" id="restartBtn">é‡æ–°é–‹å§‹</button>
        </div>

        <div class="hint">ğŸ–±ï¸ å·¦éµ:æŒ–é–‹ / å³éµ:æ’æ——<br>ğŸ“± çŸ­æŒ‰:æŒ–é–‹ / é•·æŒ‰:æ’æ——</div>
    </footer>

<script>
    const grid = document.getElementById('grid');
    const statusMsg = document.getElementById('status-msg');
    const mineCountEl = document.getElementById('mineCount');
    const modeSelector = document.getElementById('mode-selector');
    const restartArea = document.getElementById('restart-area');
    const restartBtn = document.getElementById('restartBtn');
    const gridContainer = document.getElementById('grid-container');

    let ROWS = 10, COLS = 10, MINES = 10;
    let board = []; 
    let isGameOver = false;
    let flagsLeft = 0;
    let audioCtx;
    let cellSize = 35; // æ ¼å­å¤§å°

    function playTone(freq, type='sine', d=0.1) {
        if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if(audioCtx.state === 'suspended') audioCtx.resume();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = type; o.frequency.setValueAtTime(freq, audioCtx.currentTime);
        g.gain.setValueAtTime(0.1, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + d);
        o.connect(g); g.connect(audioCtx.destination);
        o.start(); o.stop(audioCtx.currentTime + d);
    }

    // æ ¹æ“šè¢å¹•è¨ˆç®—åˆé©çš„ç¶²æ ¼
    function calculateGrid(difficulty) {
        const wrapper = document.getElementById('game-wrapper');
        // å–å¾—å¯ç”¨ç©ºé–“ (æ‰£æ‰é‚Šè·)
        const w = wrapper.clientWidth - 20;
        const h = wrapper.clientHeight - 60; // æ‰£æ‰æ–‡å­—é«˜åº¦
        
        // è¨ˆç®—è¢å¹•æœ€å¤šèƒ½å¡å¹¾æ ¼
        const maxCols = Math.floor(w / (cellSize + 2));
        const maxRows = Math.floor(h / (cellSize + 2));

        if (difficulty === 'easy') {
            // ç°¡å–®ï¼šè¼ƒå°ç¯„åœï¼Œä½å¯†åº¦ (12%)
            COLS = Math.min(10, maxCols);
            ROWS = Math.min(12, maxRows);
            MINES = Math.floor(COLS * ROWS * 0.12);
        } else if (difficulty === 'normal') {
            // æ™®é€šï¼šå¡«æ»¿å¯¬åº¦ï¼Œé«˜åº¦é©ä¸­ï¼Œä¸­å¯†åº¦ (16%)
            COLS = Math.max(10, Math.floor(maxCols * 0.9)); 
            ROWS = Math.max(10, Math.floor(maxRows * 0.8));
            MINES = Math.floor(COLS * ROWS * 0.16);
        } else {
            // å›°é›£ï¼šå¡«æ»¿å…¨è¢å¹•ï¼Œé«˜å¯†åº¦ (22%)
            COLS = maxCols;
            ROWS = maxRows;
            MINES = Math.floor(COLS * ROWS * 0.22);
        }
        
        // ä¿®æ­£ï¼šæœ€å°‘è¦æœ‰é›·
        MINES = Math.max(3, MINES);
    }

    function startGame(difficulty) {
        calculateGrid(difficulty);
        initGame();
    }

    function initGame() {
        isGameOver = false;
        flagsLeft = MINES;
        statusMsg.innerText = "";
        mineCountEl.innerText = flagsLeft;
        
        // åˆ‡æ›æŒ‰éˆ•é¡¯ç¤º
        modeSelector.style.display = 'none';
        restartArea.style.display = 'none';
        
        grid.style.gridTemplateColumns = `repeat(${COLS}, ${cellSize}px)`;
        grid.innerHTML = '';
        board = [];

        // å»ºç«‹æ ¼å­
        for (let r = 0; r < ROWS; r++) {
            let row = [];
            for (let c = 0; c < COLS; c++) {
                const cell = document.createElement('div');
                cell.classList.add('cell', 'closed');
                cell.dataset.r = r; cell.dataset.c = c;
                attachEvents(cell, r, c);
                grid.appendChild(cell);
                
                row.push({
                    r, c, isMine: false, isOpen: false, isFlagged: false, count: 0, element: cell
                });
            }
            board.push(row);
        }

        // ä½ˆé›·
        let minesPlaced = 0;
        while(minesPlaced < MINES) {
            const rr = Math.floor(Math.random() * ROWS);
            const cc = Math.floor(Math.random() * COLS);
            if(!board[rr][cc].isMine) {
                board[rr][cc].isMine = true;
                minesPlaced++;
            }
        }

        // è¨ˆç®—æ•¸å­—
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                if(!board[r][c].isMine) {
                    let count = 0;
                    for(let i=-1; i<=1; i++) {
                        for(let j=-1; j<=1; j++) {
                            const nr = r+i, nc = c+j;
                            if(nr>=0 && nr<ROWS && nc>=0 && nc<COLS && board[nr][nc].isMine) count++;
                        }
                    }
                    board[r][c].count = count;
                }
            }
        }
    }

    function attachEvents(cell, r, c) {
        let timer;
        let isLongPress = false;

        cell.addEventListener('touchstart', (e) => {
            if(isGameOver) return;
            isLongPress = false;
            timer = setTimeout(() => {
                isLongPress = true;
                playTone(300, 'square', 0.05);
                if(navigator.vibrate) navigator.vibrate(50);
                toggleFlag(r, c);
            }, 500); 
        }, {passive: false});

        cell.addEventListener('touchend', (e) => {
            if(isGameOver) return;
            clearTimeout(timer);
            if(!isLongPress) {
                e.preventDefault(); 
                reveal(r, c);
            }
        });

        cell.addEventListener('mousedown', (e) => {
            if(isGameOver) return;
            if(e.button === 0) reveal(r, c);
            else if(e.button === 2) toggleFlag(r, c);
        });

        cell.addEventListener('contextmenu', e => e.preventDefault());
    }

    function toggleFlag(r, c) {
        const cellData = board[r][c];
        if(cellData.isOpen) return;

        cellData.isFlagged = !cellData.isFlagged;
        cellData.element.innerText = cellData.isFlagged ? 'ğŸš©' : '';
        
        flagsLeft += cellData.isFlagged ? -1 : 1;
        mineCountEl.innerText = flagsLeft;
    }

    function reveal(r, c) {
        if(r < 0 || r >= ROWS || c < 0 || c >= COLS) return;
        const cellData = board[r][c];
        if(cellData.isOpen || cellData.isFlagged || isGameOver) return;

        cellData.isOpen = true;
        cellData.element.classList.remove('closed');
        cellData.element.classList.add('open');

        // è¸©åˆ°é›·
        if(cellData.isMine) {
            cellData.element.classList.add('boom');
            cellData.element.innerText = 'ğŸ’¥';
            gameOver(false);
            return;
        }

        playTone(600 + (Math.random()*200));

        if(cellData.count > 0) {
            cellData.element.innerText = cellData.count;
            cellData.element.classList.add(`c-${cellData.count}`);
        } else {
            for(let i=-1; i<=1; i++) {
                for(let j=-1; j<=1; j++) {
                    reveal(r+i, c+j);
                }
            }
        }
        checkWin();
    }

    function checkWin() {
        let closedCount = 0;
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                if(!board[r][c].isOpen) closedCount++;
            }
        }
        if(closedCount === MINES) gameOver(true);
    }

    function gameOver(win) {
        isGameOver = true;
        
        if(win) {
            statusMsg.innerText = "YOU WIN! ğŸ‰";
            statusMsg.style.color = "#00ff00";
            playTone(800, 'triangle', 0.5);
            flagAllMines();
        } else {
            statusMsg.innerText = "GAME OVER";
            statusMsg.style.color = "#ff0055";
            playTone(150, 'sawtooth', 0.8);
            revealAllMap(); // é¡¯ç¤ºå…¨åœ– (å«æ•¸å­—èˆ‡åœ°é›·)
        }
        
        // é¡¯ç¤ºé‡æ–°é¸æ“‡é›£åº¦
        modeSelector.style.display = 'none';
        restartArea.style.display = 'block';
    }

    function flagAllMines() {
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                if(board[r][c].isMine && !board[r][c].isFlagged) {
                    board[r][c].element.innerText = 'ğŸš©';
                    board[r][c].element.classList.add('correct-flag');
                }
            }
        }
    }

    // === é—œéµä¿®æ­£ï¼šå¤±æ•—æ™‚é¡¯ç¤ºå…¨åœ– (å«æ•¸å­—) ===
    function revealAllMap() {
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                const cell = board[r][c];
                
                // 1. å¦‚æœå·²ç¶“æ‰“é–‹ï¼Œè·³é
                if (cell.isOpen) continue;

                // 2. æ‰“é–‹æ ¼å­
                cell.element.classList.remove('closed');
                cell.element.classList.add('open');

                // 3. åˆ¤æ–·å…§å®¹
                if (cell.isMine) {
                    // æ˜¯é›·
                    if (cell.isFlagged) {
                        cell.element.innerText = 'ğŸš©';
                        cell.element.classList.add('correct-flag');
                    } else {
                        cell.element.innerText = 'ğŸ’£';
                        cell.element.classList.add('revealed-mine');
                    }
                } else {
                    // ä¸æ˜¯é›·
                    if (cell.isFlagged) {
                        // æ’éŒ¯æ——
                        cell.element.innerText = 'âŒ';
                        cell.element.classList.add('wrong-flag');
                    } else if (cell.count > 0) {
                        // é¡¯ç¤ºæ•¸å­—
                        cell.element.innerText = cell.count;
                        cell.element.classList.add(`c-${cell.count}`);
                    }
                    // å¦‚æœæ˜¯0ï¼Œå°±ä¿æŒç©ºç™½ (open æ¨£å¼)
                }
            }
        }
    }

    // é‡æ–°é–‹å§‹æŒ‰éˆ• -> å›åˆ°æ¨¡å¼é¸æ“‡
    restartBtn.onclick = () => {
        statusMsg.innerText = "è«‹é¸æ“‡é›£åº¦";
        grid.innerHTML = ''; // æ¸…ç©ºæ ¼å­
        restartArea.style.display = 'none';
        modeSelector.style.display = 'flex';
    };

    // é è¨­é¡¯ç¤ºæ¨¡å¼é¸æ“‡
</script>
</body>
</html>
