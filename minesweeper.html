<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è¸©åœ°é›·ï¼šéœ“è™¹æ²è»¸ç‰ˆ</title>
    <style>
        :root { --bg: #050510; --accent: #00f2ff; --danger: #ff0055; --panel: #161b22; }
        body { 
            background: var(--bg); color: white; margin: 0; 
            font-family: "Segoe UI", system-ui, sans-serif; 
            height: 100vh; display: flex; flex-direction: column; overflow: hidden;
            user-select: none;
        }

        /* é ‚éƒ¨è³‡è¨Šåˆ— */
        header {
            padding: 10px 15px; background: rgba(22, 27, 34, 0.95);
            border-bottom: 1px solid rgba(255,255,255,0.15);
            display: flex; justify-content: space-between; align-items: center;
            z-index: 10; flex-shrink: 0; box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        
        .header-left { display: flex; align-items: center; gap: 12px; }
        
        .home-btn {
            text-decoration: none; font-size: 18px; color: #fff;
            background: rgba(255,255,255,0.1); width: 36px; height: 36px;
            display: flex; align-items: center; justify-content: center;
            border-radius: 8px; border: 1px solid rgba(255,255,255,0.2);
            transition: all 0.2s;
        }
        .home-btn:active { transform: scale(0.9); background: var(--accent); color: #000; border-color: var(--accent); }

        .game-title { font-weight: 900; font-size: 18px; letter-spacing: 1px; color: #fff; }
        
        .hud { display: flex; gap: 15px; font-size: 18px; font-weight: bold; font-family: monospace; }
        .hud-item { color: var(--accent); display: flex; align-items: center; gap: 5px; }
        .hud-item span { color: #fff; text-shadow: 0 0 5px var(--accent); min-width: 30px; text-align: right; }

        /* éŠæˆ²æ²è»¸å€åŸŸ */
        #game-container {
            flex-grow: 1; overflow: auto; 
            position: relative;
            background: radial-gradient(circle, #0a0a1a 0%, #000 100%);
            display: grid; place-items: center;
            touch-action: none; 
            -webkit-overflow-scrolling: touch;
        }

        canvas { 
            display: block; 
            box-shadow: 0 0 40px rgba(0, 242, 255, 0.05);
            border-radius: 4px;
            margin: 20px;
        }

        /* åº•éƒ¨æ§åˆ¶é¢æ¿ */
        #controls {
            padding: 15px; background: var(--panel);
            border-top: 1px solid rgba(255,255,255,0.1);
            display: flex; justify-content: center; gap: 10px;
            z-index: 10; flex-shrink: 0;
            padding-bottom: max(15px, env(safe-area-inset-bottom));
        }
        select, button {
            padding: 10px 15px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2);
            background: #222; color: white; font-size: 14px; outline: none;
        }
        button.restart {
            background: var(--accent); color: #000; font-weight: bold; border: none;
            box-shadow: 0 0 15px rgba(0, 242, 255, 0.3);
        }
        button:active { transform: scale(0.96); }

        /* çµç®—ç•«é¢ */
        #overlay {
            position: absolute; inset: 0; background: rgba(0,0,0,0.85);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 20; backdrop-filter: blur(5px); display: none;
        }
        h1 { font-size: 40px; margin: 0 0 10px 0; text-shadow: 0 0 20px currentColor; }
        p { color: #ccc; margin-bottom: 20px; }
    </style>
</head>
<body>

    <header>
        <div class="header-left">
            <a href="index.html" class="home-btn">ğŸ </a>
            <div class="game-title">MINESWEEPER</div>
        </div>
        <div class="hud">
            <div class="hud-item">ğŸš© <span id="flagVal">0</span></div>
            <div class="hud-item">â±ï¸ <span id="timeVal">0</span></div>
        </div>
    </header>

    <div id="game-container">
        <canvas id="c"></canvas>
    </div>

    <div id="controls">
        <select id="mode">
            <option value="9,9,10">åˆç´š (9x9)</option>
            <option value="16,16,40" selected>ä¸­ç´š (16x16)</option>
            <option value="30,16,99">é«˜ç´š (30x16)</option>
            <option value="custom">âš™ï¸ è‡ªè¨‚...</option>
        </select>
        <button class="restart" onclick="startGame()">â†º é‡æ–°é–‹å§‹</button>
    </div>

    <div id="overlay">
        <h1 id="end-title">GAME OVER</h1>
        <p id="end-desc">ä»»å‹™å¤±æ•—</p>
        <button class="restart" onclick="startGame()">å†æ¬¡æŒ‘æˆ°</button>
    </div>

<script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('game-container');
    const overlay = document.getElementById('overlay');
    const flagEl = document.getElementById('flagVal');
    const timeEl = document.getElementById('timeVal');
    const modeSel = document.getElementById('mode');

    let cols, rows, mines, cellSize = 34;
    let grid = [], particles = [];
    let state = 'idle'; 
    let flags = 0, startTime = 0, timerInt = null;
    let dpr = window.devicePixelRatio || 1;
    
    // éŸ³æ•ˆ
    let audioCtx;
    function playSfx(type) {
        if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if(audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        osc.connect(g); g.connect(audioCtx.destination);
        const now = audioCtx.currentTime;
        
        if(type === 'click') {
            osc.frequency.setValueAtTime(800, now);
            osc.frequency.exponentialRampToValueAtTime(1200, now + 0.05);
            g.gain.setValueAtTime(0.1, now);
            g.gain.linearRampToValueAtTime(0, now + 0.05);
            osc.start(); osc.stop(now + 0.05);
        } else if(type === 'flag') {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(400, now);
            g.gain.setValueAtTime(0.1, now);
            g.gain.linearRampToValueAtTime(0, now + 0.1);
            osc.start(); osc.stop(now + 0.1);
        } else if(type === 'boom') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, now);
            osc.frequency.exponentialRampToValueAtTime(10, now + 0.5);
            g.gain.setValueAtTime(0.3, now);
            g.gain.linearRampToValueAtTime(0, now + 0.5);
            osc.start(); osc.stop(now + 0.5);
        } else if(type === 'win') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(400, now);
            osc.frequency.linearRampToValueAtTime(800, now + 0.2);
            g.gain.setValueAtTime(0.1, now);
            g.gain.linearRampToValueAtTime(0, now + 0.4);
            osc.start(); osc.stop(now + 0.4);
        }
    }

    function startGame() {
        overlay.style.display = 'none';
        state = 'idle';
        flags = 0;
        clearInterval(timerInt);
        timeEl.innerText = '0';
        particles = [];

        // --- ä¿®æ­£ï¼šè‡ªè¨‚æ¨¡å¼é‚è¼¯ ---
        let val = modeSel.value;
        if(val === 'custom') {
            // è·³å‡ºè¼¸å…¥æ¡†ï¼Œä¸¦çµ¦äºˆé è¨­å€¼
            let c = prompt("è«‹è¼¸å…¥å¯¬åº¦ (æ ¼æ•¸ 5-50):", "20");
            let r = prompt("è«‹è¼¸å…¥é«˜åº¦ (æ ¼æ•¸ 5-50):", "30");
            let m = prompt("è«‹è¼¸å…¥åœ°é›·æ•¸:", "100");

            // å¦‚æœç©å®¶æŒ‰å–æ¶ˆï¼Œé è¨­å›ä¸­ç´š
            if(c === null || r === null || m === null) {
                modeSel.value = "16,16,40";
                [cols, rows, mines] = [16, 16, 40];
            } else {
                // è½‰æ›æ•¸å­—ä¸¦åŠ ä¸Šé™åˆ¶ï¼Œé¿å…ç€è¦½å™¨ç•¶æ©Ÿ
                cols = parseInt(c) || 20;
                rows = parseInt(r) || 30;
                mines = parseInt(m) || 100;

                cols = Math.max(5, Math.min(cols, 50)); // é™åˆ¶å¯¬åº¦ 5~50
                rows = Math.max(5, Math.min(rows, 50)); // é™åˆ¶é«˜åº¦ 5~50
                mines = Math.max(1, Math.min(mines, (cols * rows) - 1)); // åœ°é›·ä¸èƒ½æ¯”æ ¼å­å¤š
            }
        } else {
            [cols, rows, mines] = val.split(',').map(Number);
        }
        flagEl.innerText = mines;

        // åˆå§‹åŒ–ç•«å¸ƒ
        canvas.width = cols * cellSize * dpr;
        canvas.height = rows * cellSize * dpr;
        canvas.style.width = (cols * cellSize) + 'px';
        canvas.style.height = (rows * cellSize) + 'px';
        ctx.scale(dpr, dpr);

        // åˆå§‹åŒ–ç¶²æ ¼
        grid = [];
        for(let y=0; y<rows; y++) {
            let row = [];
            for(let x=0; x<cols; x++) {
                row.push({ isMine: false, state: 'hidden', neighbor: 0, x: x, y: y, anim: 0 });
            }
            grid.push(row);
        }
        draw();
    }

    function placeMines(firstX, firstY) {
        let placed = 0;
        while(placed < mines) {
            let x = Math.floor(Math.random() * cols);
            let y = Math.floor(Math.random() * rows);
            
            // æˆ°è¡“ä¿®æ­£ï¼šåªé¿é–‹ç¬¬ä¸€é»æ“Šçš„é‚£ä¸€æ ¼ï¼Œè®“å‘¨åœå¯èƒ½æœ‰é›·
            if(!grid[y][x].isMine && (x !== firstX || y !== firstY)) {
                grid[y][x].isMine = true;
                placed++;
            }
        }
        
        for(let y=0; y<rows; y++) {
            for(let x=0; x<cols; x++) {
                if(grid[y][x].isMine) continue;
                let n = 0;
                for(let dy=-1; dy<=1; dy++) for(let dx=-1; dx<=1; dx++) {
                    let ny=y+dy, nx=x+dx;
                    if(ny>=0 && ny<rows && nx>=0 && nx<cols && grid[ny][nx].isMine) n++;
                }
                grid[y][x].neighbor = n;
            }
        }
        state = 'playing';
        startTime = Date.now();
        timerInt = setInterval(() => {
            timeEl.innerText = Math.floor((Date.now() - startTime)/1000);
        }, 1000);
    }

    function reveal(x, y) {
        if(x<0 || x>=cols || y<0 || y>=rows) return;
        let cell = grid[y][x];
        if(cell.state !== 'hidden') return;

        if(state === 'idle') placeMines(x, y);

        cell.state = 'revealed';
        cell.anim = 1; 
        
        if(cell.isMine) {
            gameOver(false, x, y);
            return;
        }

        playSfx('click');
        if(cell.neighbor === 0) {
            for(let dy=-1; dy<=1; dy++) for(let dx=-1; dx<=1; dx++) reveal(x+dx, y+dy);
        }
        checkWin();
    }

    function toggleFlag(x, y) {
        if(state === 'over') return;
        let cell = grid[y][x];
        if(cell.state === 'revealed') return;

        if(cell.state === 'hidden') {
            if(flags < mines) {
                cell.state = 'flagged';
                flags++;
                playSfx('flag');
                if(navigator.vibrate) navigator.vibrate(50);
            }
        } else {
            cell.state = 'hidden';
            flags--;
            playSfx('flag');
        }
        flagEl.innerText = mines - flags;
    }

    function gameOver(win, ex, ey) {
        state = 'over';
        clearInterval(timerInt);
        if(!win) {
            playSfx('boom');
            if(navigator.vibrate) navigator.vibrate(300);
            for(let i=0; i<30; i++) {
                particles.push({
                    x: ex * cellSize + cellSize/2, y: ey * cellSize + cellSize/2,
                    vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10,
                    life: 1.0, color: '#ff0055'
                });
            }
            grid.forEach(row => row.forEach(c => {
                if(c.isMine) c.state = 'revealed';
            }));
            document.getElementById('end-title').innerText = "BOOM!";
            document.getElementById('end-title').style.color = "#ff0055";
            document.getElementById('end-desc').innerText = "è§¸ç™¼åœ°é›·";
        } else {
            playSfx('win');
            document.getElementById('end-title').innerText = "SUCCESS";
            document.getElementById('end-title').style.color = "#00f2ff";
            document.getElementById('end-desc').innerText = "ä»»å‹™å®Œæˆ";
        }
        setTimeout(() => overlay.style.display = 'flex', 1000);
    }

    function checkWin() {
        let covered = 0;
        grid.forEach(r => r.forEach(c => {
            if(!c.isMine && c.state !== 'revealed') covered++;
        }));
        if(covered === 0) gameOver(true);
    }

    function draw() {
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        grid.forEach(row => row.forEach(c => {
            let px = c.x * cellSize;
            let py = c.y * cellSize;
            
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            ctx.strokeRect(px, py, cellSize, cellSize);

            if(c.state === 'hidden' || c.state === 'flagged') {
                let grad = ctx.createLinearGradient(px, py, px+cellSize, py+cellSize);
                grad.addColorStop(0, '#2a2a3a');
                grad.addColorStop(1, '#161622');
                ctx.fillStyle = grad;
                ctx.fillRect(px+1, py+1, cellSize-2, cellSize-2);

                if(c.state === 'flagged') {
                    ctx.fillStyle = '#ff0055';
                    ctx.font = (cellSize * 0.6) + 'px Arial';
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText('ğŸš©', px + cellSize/2, py + cellSize/2);
                }
            } else {
                ctx.fillStyle = c.isMine ? '#300' : '#0a0a10';
                ctx.fillRect(px, py, cellSize, cellSize);

                if(c.anim > 0) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${c.anim * 0.3})`;
                    ctx.fillRect(px, py, cellSize, cellSize);
                    c.anim -= 0.05;
                }

                if(c.isMine) {
                    ctx.fillStyle = '#f00';
                    ctx.font = (cellSize * 0.6) + 'px Arial';
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.shadowBlur = 10; ctx.shadowColor = 'red';
                    ctx.fillText('ğŸ’£', px + cellSize/2, py + cellSize/2);
                    ctx.shadowBlur = 0;
                } else if(c.neighbor > 0) {
                    const colors = [null, '#0ff', '#0f0', '#f00', '#00f', '#800', '#088', '#aaa', '#fff'];
                    ctx.fillStyle = colors[c.neighbor];
                    ctx.font = 'bold ' + (cellSize * 0.6) + 'px monospace';
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.shadowBlur = 5; ctx.shadowColor = colors[c.neighbor];
                    ctx.fillText(c.neighbor, px + cellSize/2, py + cellSize/2);
                    ctx.shadowBlur = 0;
                }
            }
        }));

        ctx.globalCompositeOperation = 'lighter';
        for(let i=particles.length-1; i>=0; i--) {
            let p = particles[i];
            ctx.fillStyle = p.color;
            ctx.beginPath(); ctx.arc(p.x, p.y, 4 * p.life, 0, Math.PI*2); ctx.fill();
            p.x += p.vx; p.y += p.vy;
            p.life -= 0.03;
            if(p.life <= 0) particles.splice(i, 1);
        }
        ctx.globalCompositeOperation = 'source-over';

        requestAnimationFrame(draw);
    }

    let longPressTimer, startX, startY;
    
    function getCellFromEvent(e) {
        let rect = canvas.getBoundingClientRect();
        let clientX = e.touches ? e.touches[0].clientX : e.clientX;
        let clientY = e.touches ? e.touches[0].clientY : e.clientY;
        let x = Math.floor((clientX - rect.left) / (rect.width / cols));
        let y = Math.floor((clientY - rect.top) / (rect.height / rows));
        return {x, y};
    }

    canvas.addEventListener('mousedown', e => {
        if(e.button === 2) { 
            let c = getCellFromEvent(e);
            toggleFlag(c.x, c.y);
        } else {
            let c = getCellFromEvent(e);
            reveal(c.x, c.y);
        }
    });
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    canvas.addEventListener('touchstart', e => {
        if(state === 'over') return;
        let c = getCellFromEvent(e);
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
        
        longPressTimer = setTimeout(() => {
            toggleFlag(c.x, c.y);
            longPressTimer = null;
        }, 300); 
    }, {passive: false});

    canvas.addEventListener('touchmove', e => {
        let dx = e.touches[0].clientX - startX;
        let dy = e.touches[0].clientY - startY;
        if(Math.abs(dx) > 10 || Math.abs(dy) > 10) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
        }
    }, {passive: false});

    canvas.addEventListener('touchend', e => {
        if(longPressTimer) { 
            clearTimeout(longPressTimer);
            let rect = canvas.getBoundingClientRect();
            let x = Math.floor((startX - rect.left) / (rect.width / cols));
            let y = Math.floor((startY - rect.top) / (rect.height / rows));
            reveal(x, y);
        }
    });

    modeSel.addEventListener('change', startGame);
    startGame();

</script>
</body>
</html>
