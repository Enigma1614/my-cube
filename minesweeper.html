<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è¸©åœ°é›·ï¼šéœ“è™¹æ²è»¸ç‰ˆ</title>
    <style>
        :root { --bg: #050510; --accent: #00f2ff; --danger: #ff0055; --panel: #161b22; }
        body { 
            background: var(--bg); color: white; margin: 0; 
            font-family: "Segoe UI", system-ui, sans-serif; 
            height: 100vh; display: flex; flex-direction: column; overflow: hidden;
        }

        /* é ‚éƒ¨è³‡è¨Šåˆ— */
        header {
            padding: 10px 15px; background: rgba(22, 27, 34, 0.9);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex; justify-content: space-between; align-items: center;
            z-index: 10; flex-shrink: 0; box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        .hud { display: flex; gap: 15px; font-size: 18px; font-weight: bold; font-family: monospace; }
        .hud-item { color: var(--accent); display: flex; align-items: center; gap: 5px; }
        .hud-item span { color: #fff; text-shadow: 0 0 5px var(--accent); }

        /* éŠæˆ²æ²è»¸å€åŸŸ (é—œéµä¿®æ”¹ï¼šå…è¨±æ»‘å‹•) */
        #game-container {
            flex-grow: 1; overflow: auto; /* å…è¨±å·è»¸ */
            position: relative;
            background: radial-gradient(circle, #0a0a1a 0%, #000 100%);
            display: grid; place-items: center; /* è®“å°æ£‹ç›¤ç½®ä¸­ */
            touch-action: pan-x pan-y; /* å…è¨±ç€è¦½å™¨è™•ç†æ»‘å‹• */
            -webkit-overflow-scrolling: touch;
        }

        canvas { 
            display: block; 
            box-shadow: 0 0 30px rgba(0, 242, 255, 0.1);
            border-radius: 4px;
            margin: 20px; /* é‚Šè· */
        }

        /* åº•éƒ¨æ§åˆ¶é¢æ¿ */
        #controls {
            padding: 15px; background: var(--panel);
            border-top: 1px solid rgba(255,255,255,0.1);
            display: flex; justify-content: center; gap: 10px;
            z-index: 10; flex-shrink: 0;
            padding-bottom: max(15px, env(safe-area-inset-bottom));
        }
        select, button {
            padding: 10px 15px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2);
            background: #222; color: white; font-size: 14px; outline: none;
        }
        button.restart {
            background: var(--accent); color: #000; font-weight: bold; border: none;
            box-shadow: 0 0 15px rgba(0, 242, 255, 0.3);
        }
        button:active { transform: scale(0.96); }

        /* çµç®—ç•«é¢ */
        #overlay {
            position: absolute; inset: 0; background: rgba(0,0,0,0.85);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 20; backdrop-filter: blur(5px); display: none;
        }
        h1 { font-size: 40px; margin: 0 0 10px 0; text-shadow: 0 0 20px currentColor; }
        p { color: #ccc; margin-bottom: 20px; }
    </style>
</head>
<body>

    <header>
        <div style="font-weight:900; color:#fff;">MINESWEEPER</div>
        <div class="hud">
            <div class="hud-item">ğŸš© <span id="flagVal">0</span></div>
            <div class="hud-item">â±ï¸ <span id="timeVal">0</span></div>
        </div>
    </header>

    <div id="game-container">
        <canvas id="c"></canvas>
    </div>

    <div id="controls">
        <select id="mode">
            <option value="9,9,10">åˆç´š (9x9)</option>
            <option value="16,16,40" selected>ä¸­ç´š (16x16)</option>
            <option value="30,16,99">é«˜ç´š (30x16)</option>
            <option value="custom">è‡ªè¨‚...</option>
        </select>
        <button class="restart" onclick="startGame()">â†º é‡æ–°é–‹å§‹</button>
    </div>

    <div id="overlay">
        <h1 id="end-title">GAME OVER</h1>
        <p id="end-desc">ä»»å‹™å¤±æ•—</p>
        <button class="restart" onclick="startGame()">å†æ¬¡æŒ‘æˆ°</button>
    </div>

<script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('game-container');
    const overlay = document.getElementById('overlay');
    const flagEl = document.getElementById('flagVal');
    const timeEl = document.getElementById('timeVal');
    const modeSel = document.getElementById('mode');

    let cols, rows, mines, cellSize = 34; // å›ºå®šçš„èˆ’é©æ ¼å­å¤§å°
    let grid = [], particles = [];
    let state = 'idle'; // idle, playing, over
    let flags = 0, startTime = 0, timerInt = null;
    let dpr = window.devicePixelRatio || 1;
    
    // è‡ªè¨‚éŸ³æ•ˆä¸Šä¸‹æ–‡
    let audioCtx;
    function playSfx(type) {
        if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if(audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        osc.connect(g); g.connect(audioCtx.destination);
        const now = audioCtx.currentTime;
        
        if(type === 'click') {
            osc.frequency.setValueAtTime(800, now);
            osc.frequency.exponentialRampToValueAtTime(1200, now + 0.05);
            g.gain.setValueAtTime(0.1, now);
            g.gain.linearRampToValueAtTime(0, now + 0.05);
            osc.start(); osc.stop(now + 0.05);
        } else if(type === 'flag') {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(400, now);
            g.gain.setValueAtTime(0.1, now);
            g.gain.linearRampToValueAtTime(0, now + 0.1);
            osc.start(); osc.stop(now + 0.1);
        } else if(type === 'boom') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, now);
            osc.frequency.exponentialRampToValueAtTime(10, now + 0.5);
            g.gain.setValueAtTime(0.3, now);
            g.gain.linearRampToValueAtTime(0, now + 0.5);
            osc.start(); osc.stop(now + 0.5);
        } else if(type === 'win') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(400, now);
            osc.frequency.linearRampToValueAtTime(800, now + 0.2);
            g.gain.setValueAtTime(0.1, now);
            g.gain.linearRampToValueAtTime(0, now + 0.4);
            osc.start(); osc.stop(now + 0.4);
        }
    }

    function startGame() {
        overlay.style.display = 'none';
        state = 'idle';
        flags = 0;
        clearInterval(timerInt);
        timeEl.innerText = '0';
        particles = [];

        // è®€å–è¨­å®š
        let val = modeSel.value;
        if(val === 'custom') {
            // ç°¡å–®çš„è‡ªè¨‚é‚è¼¯é˜²å‘†
            cols = 20; rows = 20; mines = 50;
        } else {
            [cols, rows, mines] = val.split(',').map(Number);
        }
        flagEl.innerText = mines;

        // åˆå§‹åŒ–ç•«å¸ƒ (Retina æ”¯æ´)
        // é—œéµä¿®æ­£ï¼šç•«å¸ƒå¤§å°æ ¹æ“šæ ¼å­æ•¸é‡æ±ºå®šï¼Œä¸éš¨è¢å¹•ç¸®æ”¾
        canvas.width = cols * cellSize * dpr;
        canvas.height = rows * cellSize * dpr;
        canvas.style.width = (cols * cellSize) + 'px';
        canvas.style.height = (rows * cellSize) + 'px';
        ctx.scale(dpr, dpr);

        // åˆå§‹åŒ–ç¶²æ ¼
        grid = [];
        for(let y=0; y<rows; y++) {
            let row = [];
            for(let x=0; x<cols; x++) {
                row.push({
                    isMine: false, state: 'hidden', neighbor: 0,
                    x: x, y: y, anim: 0 // å‹•ç•«åƒæ•¸
                });
            }
            grid.push(row);
        }
        draw();
    }

    function placeMines(firstX, firstY) {
        let placed = 0;
        while(placed < mines) {
            let x = Math.floor(Math.random() * cols);
            let y = Math.floor(Math.random() * rows);
            // ç¢ºä¿ç¬¬ä¸€ä¸‹é»æ“Šå‘¨åœå®‰å…¨
            if(!grid[y][x].isMine && Math.abs(x - firstX) > 1 && Math.abs(y - firstY) > 1) {
                grid[y][x].isMine = true;
                placed++;
            }
        }
        // è¨ˆç®—æ•¸å­—
        for(let y=0; y<rows; y++) {
            for(let x=0; x<cols; x++) {
                if(grid[y][x].isMine) continue;
                let n = 0;
                for(let dy=-1; dy<=1; dy++) for(let dx=-1; dx<=1; dx++) {
                    let ny=y+dy, nx=x+dx;
                    if(ny>=0 && ny<rows && nx>=0 && nx<cols && grid[ny][nx].isMine) n++;
                }
                grid[y][x].neighbor = n;
            }
        }
        state = 'playing';
        startTime = Date.now();
        timerInt = setInterval(() => {
            timeEl.innerText = Math.floor((Date.now() - startTime)/1000);
        }, 1000);
    }

    function reveal(x, y) {
        if(x<0 || x>=cols || y<0 || y>=rows) return;
        let cell = grid[y][x];
        if(cell.state !== 'hidden') return;

        if(state === 'idle') placeMines(x, y);

        cell.state = 'revealed';
        cell.anim = 1; // è§¸ç™¼å‹•ç•«
        
        if(cell.isMine) {
            gameOver(false, x, y);
            return;
        }

        playSfx('click');
        if(cell.neighbor === 0) {
            // æ“´æ•£é‚è¼¯
            for(let dy=-1; dy<=1; dy++) for(let dx=-1; dx<=1; dx++) reveal(x+dx, y+dy);
        }
        checkWin();
    }

    function toggleFlag(x, y) {
        if(state === 'over') return;
        let cell = grid[y][x];
        if(cell.state === 'revealed') return;

        if(cell.state === 'hidden') {
            if(flags < mines) {
                cell.state = 'flagged';
                flags++;
                playSfx('flag');
                if(navigator.vibrate) navigator.vibrate(50);
            }
        } else {
            cell.state = 'hidden';
            flags--;
            playSfx('flag');
        }
        flagEl.innerText = mines - flags;
    }

    function gameOver(win, ex, ey) {
        state = 'over';
        clearInterval(timerInt);
        
        if(!win) {
            // çˆ†ç‚¸ç‰¹æ•ˆ
            playSfx('boom');
            if(navigator.vibrate) navigator.vibrate(300);
            // ç”¢ç”Ÿå¤§é‡ç²’å­
            for(let i=0; i<30; i++) {
                particles.push({
                    x: ex * cellSize + cellSize/2, y: ey * cellSize + cellSize/2,
                    vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10,
                    life: 1.0, color: '#ff0055'
                });
            }
            // é¡¯ç¤ºæ‰€æœ‰åœ°é›·
            grid.forEach(row => row.forEach(c => {
                if(c.isMine) c.state = 'revealed';
            }));
            document.getElementById('end-title').innerText = "BOOM!";
            document.getElementById('end-title').style.color = "#ff0055";
            document.getElementById('end-desc').innerText = "è§¸ç™¼åœ°é›·";
        } else {
            playSfx('win');
            document.getElementById('end-title').innerText = "SUCCESS";
            document.getElementById('end-title').style.color = "#00f2ff";
            document.getElementById('end-desc').innerText = "ä»»å‹™å®Œæˆ";
        }
        setTimeout(() => overlay.style.display = 'flex', 1000);
    }

    function checkWin() {
        let covered = 0;
        grid.forEach(r => r.forEach(c => {
            if(!c.isMine && c.state !== 'revealed') covered++;
        }));
        if(covered === 0) gameOver(true);
    }

    // --- ç¹ªåœ–å¾ªç’° ---
    function draw() {
        // æ¸…é™¤ç•«é¢
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // ç•«ç¶²æ ¼
        grid.forEach(row => row.forEach(c => {
            let px = c.x * cellSize;
            let py = c.y * cellSize;
            
            // é‚Šæ¡†
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            ctx.strokeRect(px, py, cellSize, cellSize);

            if(c.state === 'hidden' || c.state === 'flagged') {
                // æœªç¿»é–‹çš„æ¨£å¼
                let grad = ctx.createLinearGradient(px, py, px+cellSize, py+cellSize);
                grad.addColorStop(0, '#2a2a3a');
                grad.addColorStop(1, '#161622');
                ctx.fillStyle = grad;
                ctx.fillRect(px+1, py+1, cellSize-2, cellSize-2);

                if(c.state === 'flagged') {
                    ctx.fillStyle = '#ff0055';
                    ctx.font = (cellSize * 0.6) + 'px Arial';
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText('ğŸš©', px + cellSize/2, py + cellSize/2);
                }
            } else {
                // å·²ç¿»é–‹
                ctx.fillStyle = c.isMine ? '#300' : '#0a0a10';
                ctx.fillRect(px, py, cellSize, cellSize);

                // é–‹å•Ÿå‹•ç•« (æ·¡å…¥)
                if(c.anim > 0) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${c.anim * 0.3})`;
                    ctx.fillRect(px, py, cellSize, cellSize);
                    c.anim -= 0.05;
                }

                if(c.isMine) {
                    ctx.fillStyle = '#f00';
                    ctx.font = (cellSize * 0.6) + 'px Arial';
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.shadowBlur = 10; ctx.shadowColor = 'red';
                    ctx.fillText('ğŸ’£', px + cellSize/2, py + cellSize/2);
                    ctx.shadowBlur = 0;
                } else if(c.neighbor > 0) {
                    const colors = [null, '#0ff', '#0f0', '#f00', '#00f', '#800', '#088', '#aaa', '#fff'];
                    ctx.fillStyle = colors[c.neighbor];
                    ctx.font = 'bold ' + (cellSize * 0.6) + 'px monospace';
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.shadowBlur = 5; ctx.shadowColor = colors[c.neighbor];
                    ctx.fillText(c.neighbor, px + cellSize/2, py + cellSize/2);
                    ctx.shadowBlur = 0;
                }
            }
        }));

        // ç•«ç²’å­
        ctx.globalCompositeOperation = 'lighter';
        for(let i=particles.length-1; i>=0; i--) {
            let p = particles[i];
            ctx.fillStyle = p.color;
            ctx.beginPath(); ctx.arc(p.x, p.y, 4 * p.life, 0, Math.PI*2); ctx.fill();
            p.x += p.vx; p.y += p.vy;
            p.life -= 0.03;
            if(p.life <= 0) particles.splice(i, 1);
        }
        ctx.globalCompositeOperation = 'source-over';

        requestAnimationFrame(draw);
    }

    // --- äº’å‹•æ§åˆ¶ ---
    let longPressTimer, startX, startY;
    
    // ç²å–æ ¼å­çš„å·¥å…·å‡½å¼ (è€ƒæ…®åˆ°å·è»¸ä½ç½®)
    function getCellFromEvent(e) {
        let rect = canvas.getBoundingClientRect();
        let clientX = e.touches ? e.touches[0].clientX : e.clientX;
        let clientY = e.touches ? e.touches[0].clientY : e.clientY;
        let x = Math.floor((clientX - rect.left) / (rect.width / cols));
        let y = Math.floor((clientY - rect.top) / (rect.height / rows));
        return {x, y};
    }

    canvas.addEventListener('mousedown', e => {
        if(e.button === 2) { // å³éµ
            let c = getCellFromEvent(e);
            toggleFlag(c.x, c.y);
        } else {
            let c = getCellFromEvent(e);
            reveal(c.x, c.y);
        }
    });
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    // æ‰‹æ©Ÿé•·æŒ‰é‚è¼¯
    canvas.addEventListener('touchstart', e => {
        if(state === 'over') return;
        let c = getCellFromEvent(e);
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
        
        longPressTimer = setTimeout(() => {
            toggleFlag(c.x, c.y);
            longPressTimer = null;
        }, 300); // 300ms é•·æŒ‰æ’æ——
    }, {passive: false});

    canvas.addEventListener('touchmove', e => {
        // å¦‚æœæ‰‹æŒ‡ç§»å‹•è¶…éä¸€å®šè·é›¢ï¼Œè¦–ç‚ºã€Œæ»‘å‹•ç•«é¢ã€ï¼Œå–æ¶ˆé•·æŒ‰
        let dx = e.touches[0].clientX - startX;
        let dy = e.touches[0].clientY - startY;
        if(Math.abs(dx) > 10 || Math.abs(dy) > 10) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
        }
    }, {passive: false});

    canvas.addEventListener('touchend', e => {
        if(longPressTimer) { // æ²’æœ‰è§¸ç™¼é•·æŒ‰ï¼Œè¦–ç‚ºé»æ“Š
            clearTimeout(longPressTimer);
            // ç”±æ–¼ touchend æ²’æœ‰ clientXï¼Œæˆ‘å€‘ç”¨ startX/Y è¿‘ä¼¼
            // ä½†æ›´å¥½çš„åšæ³•æ˜¯ä¸è¦åœ¨é€™è£¡è§¸ç™¼ revealï¼Œå› ç‚ºå¯èƒ½å·²ç¶“è¢«åˆ¤å®šç‚ºæ»‘å‹•
            // é€™è£¡ç°¡å–®è™•ç†ï¼šå¦‚æœæ²’è¢«å–æ¶ˆï¼Œå°±æ˜¯é»æ“Š
            let rect = canvas.getBoundingClientRect();
            let x = Math.floor((startX - rect.left) / (rect.width / cols));
            let y = Math.floor((startY - rect.top) / (rect.height / rows));
            reveal(x, y);
        }
    });

    modeSel.addEventListener('change', startGame);
    startGame();

</script>
</body>
</html>
