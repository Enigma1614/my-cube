<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ¥µé™è¸©åœ°é›·</title>
    <style>
        :root { --bg: #050510; --accent: #00d2ff; --cell-bg: #1a1a2e; --cell-hover: #262642; }
        body {
            background: var(--bg); color: white; margin: 0; 
            font-family: system-ui, -apple-system, sans-serif;
            display: flex; flex-direction: column; align-items: center;
            height: 100vh; overflow: hidden; user-select: none;
            touch-action: manipulation; /* å„ªåŒ–è§¸æ§åæ‡‰ */
        }

        /* === ä¸Šæ–¹è³‡è¨Šå€ === */
        header {
            width: 100%; padding: 15px 0;
            background: rgba(0,0,0,0.3); border-bottom: 1px solid rgba(255,255,255,0.1);
            text-align: center; flex-shrink: 0;
            display: flex; justify-content: center; align-items: center; gap: 20px;
        }
        .status-text { font-size: 24px; font-weight: 900; color: #fff; text-shadow: 0 0 10px var(--accent); }
        .mine-count { font-family: monospace; font-size: 20px; color: #f1c40f; }

        /* === éŠæˆ²ä¸»é«” === */
        #game-container {
            flex: 1; display: flex; justify-content: center; align-items: center;
            width: 100%; overflow: auto; padding: 20px; box-sizing: border-box;
        }

        #grid {
            display: grid;
            gap: 2px;
            background: #333; /* æ ¼å­ç¸«éš™é¡è‰² */
            border: 4px solid #333;
            border-radius: 4px;
            /* ç¦æ­¢ç€è¦½å™¨é è¨­å³éµé¸å–® */
            pointer-events: auto;
        }

        .cell {
            width: 35px; height: 35px;
            background: var(--cell-bg);
            display: flex; justify-content: center; align-items: center;
            font-weight: bold; font-size: 20px; cursor: pointer;
            transition: background 0.1s;
        }
        
        /* å°šæœªæŒ–é–‹çš„æ ¼å­ */
        .cell.closed:active { background: var(--cell-hover); }
        
        /* æŒ–é–‹çš„æ ¼å­ */
        .cell.open { background: #0b0b15; box-shadow: inset 0 0 5px rgba(0,0,0,0.5); }
        
        /* çˆ†ç‚¸çš„åœ°é›· */
        .cell.boom { background: #ff0055 !important; animation: shake 0.5s; }
        
        /* éŠæˆ²çµæŸé¡¯ç¤ºçš„åœ°é›· */
        .cell.revealed-mine { background: #2a0a1a; border: 1px solid #ff0055; }

        /* æ•¸å­—é¡è‰² */
        .c-1 { color: #4cc9f0; }
        .c-2 { color: #4eff4e; }
        .c-3 { color: #ff4d6d; }
        .c-4 { color: #9d4edd; }
        .c-5 { color: #ff9e00; }
        .c-6 { color: #00ffff; }
        .c-7 { color: #fff; }
        .c-8 { color: #777; }

        /* === ä¸‹æ–¹æ§åˆ¶å€ === */
        footer {
            width: 100%; padding: 20px;
            background: rgba(0,0,0,0.2);
            display: flex; flex-direction: column; align-items: center; gap: 10px;
            flex-shrink: 0; min-height: 100px;
        }

        /* é‡æ–°é–‹å§‹æŒ‰éˆ• (é è¨­éš±è—ï¼Œå¤±æ•—é¡¯ç¤º) */
        #restartBtn {
            padding: 12px 50px; font-size: 20px; font-weight: bold;
            background: var(--accent); border: none; border-radius: 50px;
            color: #000; cursor: pointer; box-shadow: 0 0 20px var(--accent);
            display: none; /* åˆå§‹éš±è— */
        }
        #restartBtn:active { transform: scale(0.95); }

        .hint { color: #888; font-size: 12px; margin-top: 5px; }

        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }
    </style>
</head>
<body>

    <header>
        <div class="status-text" id="status">MINESWEEPER</div>
        <div class="mine-count">ğŸ’£ <span id="mineCount">0</span></div>
    </header>

    <div id="game-container">
        <div id="grid"></div>
    </div>

    <footer>
        <button id="restartBtn">é‡æ–°é–‹å§‹</button>
        <div class="hint">ğŸ–±ï¸ å·¦éµ:æŒ–é–‹ / å³éµ:æ’æ——<br>ğŸ“± çŸ­æŒ‰:æŒ–é–‹ / é•·æŒ‰:æ’æ——</div>
    </footer>

<script>
    const grid = document.getElementById('grid');
    const statusEl = document.getElementById('status');
    const mineCountEl = document.getElementById('mineCount');
    const restartBtn = document.getElementById('restartBtn');

    // éŠæˆ²è¨­å®š
    let ROWS = 12;
    let COLS = 10;
    let MINES = 15;
    
    let board = []; // å„²å­˜æ ¼å­è³‡æ–™
    let isGameOver = false;
    let flagsLeft = MINES;

    // éŸ³æ•ˆç’°å¢ƒ
    let audioCtx;
    function playTone(freq, type='sine', d=0.1) {
        if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if(audioCtx.state === 'suspended') audioCtx.resume();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = type; o.frequency.setValueAtTime(freq, audioCtx.currentTime);
        g.gain.setValueAtTime(0.1, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + d);
        o.connect(g); g.connect(audioCtx.destination);
        o.start(); o.stop(audioCtx.currentTime + d);
    }

    // å‹•æ…‹è¨ˆç®—ç¶²æ ¼å¤§å°
    function resizeGame() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        
        // æ ¹æ“šè¢å¹•å¤§å°èª¿æ•´é›£åº¦èˆ‡æ ¼å­æ•¸
        if(w < 600) {
            COLS = 10; ROWS = 14; MINES = 15;
        } else {
            COLS = 18; ROWS = 12; MINES = 30;
        }
        
        // é‡æ–°é–‹å§‹
        initGame();
    }

    function initGame() {
        isGameOver = false;
        flagsLeft = MINES;
        statusEl.innerText = "MINESWEEPER";
        statusEl.style.color = "#fff";
        mineCountEl.innerText = flagsLeft;
        restartBtn.style.display = 'none'; // éš±è—é‡ä¾†æŒ‰éˆ•
        
        // è¨­å®š CSS Grid
        grid.style.gridTemplateColumns = `repeat(${COLS}, 35px)`;
        grid.innerHTML = '';
        board = [];

        // 1. å»ºç«‹è³‡æ–™çµæ§‹
        for (let r = 0; r < ROWS; r++) {
            let row = [];
            for (let c = 0; c < COLS; c++) {
                // å»ºç«‹ DOM
                const cell = document.createElement('div');
                cell.classList.add('cell', 'closed');
                cell.dataset.r = r;
                cell.dataset.c = c;
                
                // ç¶å®šäº‹ä»¶
                attachEvents(cell, r, c);

                grid.appendChild(cell);
                
                // è³‡æ–™ç‰©ä»¶
                row.push({
                    r, c,
                    isMine: false,
                    isOpen: false,
                    isFlagged: false,
                    count: 0,
                    element: cell
                });
            }
            board.push(row);
        }

        // 2. ä½ˆé›·
        let minesPlaced = 0;
        while(minesPlaced < MINES) {
            const rr = Math.floor(Math.random() * ROWS);
            const cc = Math.floor(Math.random() * COLS);
            if(!board[rr][cc].isMine) {
                board[rr][cc].isMine = true;
                minesPlaced++;
            }
        }

        // 3. è¨ˆç®—å‘¨åœåœ°é›·æ•¸
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                if(!board[r][c].isMine) {
                    let count = 0;
                    // æª¢æŸ¥ä¹å®®æ ¼
                    for(let i=-1; i<=1; i++) {
                        for(let j=-1; j<=1; j++) {
                            const nr = r+i, nc = c+j;
                            if(nr>=0 && nr<ROWS && nc>=0 && nc<COLS && board[nr][nc].isMine) {
                                count++;
                            }
                        }
                    }
                    board[r][c].count = count;
                }
            }
        }
    }

    // äº‹ä»¶ç¶å®š (åŒ…å«é•·æŒ‰è™•ç†)
    function attachEvents(cell, r, c) {
        let timer;
        let isLongPress = false;

        // è§¸æ§é–‹å§‹ (æ‰‹æ©Ÿ)
        cell.addEventListener('touchstart', (e) => {
            if(isGameOver) return;
            isLongPress = false;
            timer = setTimeout(() => {
                isLongPress = true;
                playTone(300, 'square', 0.05); // éœ‡å‹•æˆ–éŸ³æ•ˆæç¤º
                if(navigator.vibrate) navigator.vibrate(50);
                toggleFlag(r, c);
            }, 500); // 500ms é•·æŒ‰åˆ¤å®š
        }, {passive: false});

        // è§¸æ§çµæŸ
        cell.addEventListener('touchend', (e) => {
            if(isGameOver) return;
            clearTimeout(timer);
            if(!isLongPress) {
                e.preventDefault(); // é˜²æ­¢è§¸ç™¼ click
                reveal(r, c);
            }
        });

        // æ»‘é¼ é»æ“Š (é›»è…¦)
        cell.addEventListener('mousedown', (e) => {
            if(isGameOver) return;
            if(e.button === 0) { // å·¦éµ
                reveal(r, c);
            } else if(e.button === 2) { // å³éµ
                toggleFlag(r, c);
            }
        });

        // ç¦æ­¢å³éµé¸å–®
        cell.addEventListener('contextmenu', e => e.preventDefault());
    }

    // æ’æ——é‚è¼¯
    function toggleFlag(r, c) {
        const cellData = board[r][c];
        if(cellData.isOpen) return;

        cellData.isFlagged = !cellData.isFlagged;
        cellData.element.innerText = cellData.isFlagged ? 'ğŸš©' : '';
        
        flagsLeft += cellData.isFlagged ? -1 : 1;
        mineCountEl.innerText = flagsLeft;
    }

    // æŒ–é–‹é‚è¼¯
    function reveal(r, c) {
        // é‚Šç•Œæª¢æŸ¥
        if(r < 0 || r >= ROWS || c < 0 || c >= COLS) return;
        
        const cellData = board[r][c];
        if(cellData.isOpen || cellData.isFlagged || isGameOver) return;

        cellData.isOpen = true;
        cellData.element.classList.remove('closed');
        cellData.element.classList.add('open');

        // è¸©åˆ°é›·
        if(cellData.isMine) {
            cellData.element.classList.add('boom');
            cellData.element.innerText = 'ğŸ’¥';
            gameOver(false);
            return;
        }

        playTone(600 + (Math.random()*200));

        // é¡¯ç¤ºæ•¸å­—
        if(cellData.count > 0) {
            cellData.element.innerText = cellData.count;
            cellData.element.classList.add(`c-${cellData.count}`);
        } else {
            // å¦‚æœæ˜¯ 0ï¼Œæ“´æ•£ (Flood Fill)
            for(let i=-1; i<=1; i++) {
                for(let j=-1; j<=1; j++) {
                    reveal(r+i, c+j);
                }
            }
        }
        
        checkWin();
    }

    // æª¢æŸ¥æ˜¯å¦å‹åˆ©
    function checkWin() {
        let closedCount = 0;
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                if(!board[r][c].isOpen) closedCount++;
            }
        }
        if(closedCount === MINES) {
            gameOver(true);
        }
    }

    // éŠæˆ²çµæŸ (å‹åˆ©æˆ–å¤±æ•—)
    function gameOver(win) {
        isGameOver = true;
        
        if(win) {
            statusEl.innerText = "YOU WIN! ğŸ‰";
            statusEl.style.color = "#00ff00";
            playTone(800, 'triangle', 0.5);
        } else {
            statusEl.innerText = "GAME OVER ğŸ’€";
            statusEl.style.color = "#ff0055";
            playTone(150, 'sawtooth', 0.8);
            
            // å¤±æ•—æ™‚ï¼šå±•é–‹å…¨åœ°åœ–
            revealAllMines();
        }
        
        // é¡¯ç¤ºé‡æ–°é–‹å§‹æŒ‰éˆ• (ä¸æœƒæ“‹ä½ç•«é¢ï¼Œè€Œæ˜¯åœ¨ä¸‹æ–¹)
        restartBtn.style.display = 'block';
    }

    // é¡¯ç¤ºæ‰€æœ‰åœ°é›· (ä¸ä½¿ç”¨é®ç½©)
    function revealAllMines() {
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                const cell = board[r][c];
                if(cell.isMine && !cell.isOpen) {
                    cell.element.classList.remove('closed');
                    cell.element.classList.add('revealed-mine'); // ç‰¹æ®Šæ¨£å¼
                    cell.element.innerText = 'ğŸ’£';
                } else if (!cell.isMine && cell.isFlagged) {
                    // æ¨™éŒ¯çš„æ——å­
                    cell.element.innerText = 'âŒ';
                }
            }
        }
    }

    // åˆå§‹åŒ–
    window.addEventListener('resize', () => {
        // ç°¡å–®é˜²æŠ–å‹•
        clearTimeout(window.resizeTimer);
        window.resizeTimer = setTimeout(resizeGame, 200);
    });
    
    restartBtn.onclick = initGame;
    resizeGame(); // å•Ÿå‹•

</script>
</body>
</html>
